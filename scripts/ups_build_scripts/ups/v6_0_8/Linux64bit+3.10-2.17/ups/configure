#!/bin/sh

URA_Disclaimer='
# Copyright (c) 1998 Universities Research Association, Inc.
#       All Rights Reserved
#
#
# This material resulted from work developed under a Government Contract and
# is subject to the following license:  The Government retains a paid-up,
# nonexclusive, irrevocable worldwide license to reproduce, prepare derivative
# works, perform publicly and display publicly by or for the Government,
# including the right to distribute to other Government contractors.  Neither
# the United States nor the United States Department of Energy, nor any of
# their employees, makes any warranty, express or implied, or assumes any
# legal liability or responsibility for the accuracy, completeness, or
# usefulness of any information, apparatus, product, or process disclosed, or
# represents that its use would not infringe privately owned rights.
#'

Setups_Flag=SETUPS_DIR		# Name of dbconfig variable containing directory

# StartUp_Flag=UPS_START	# Name of proposed dbconfig variable to generate
				# Startup and Shutdown scripts

Setups_Products_Init_File=upsdb_list	# Name of ups database list file.

Setups_Products_Script=setups_products_init.sh	# Name of script which  parses
						# ups database list file.

Ups_Dir=$UPS_PROD_DIR		# Product home directory as passed by ups configure

Name_Of_Ups=$UPS_PROD_NAME	# Name of the ups product (Usually 'ups').

Script_Prefix=set${Name_Of_Ups}	# Script name prefix (identifies the 'set'/product)

Setups_Advanced_Sh_Str="bash ksh ash sh"	# Names to search for shell.

Setups_Commands="cat grep ln ls mkdir rm sed wc"	# Commands to be found.

#======================================================================
# The following variables are defined to permit inclusion of the
# functions  or "macros" into each of the scripts from the single
# copy thereby simplifying maintenance.
#
# The generating variables all begin with "_Make".  
#
# To embed the macro or to activate the function in the generating
# script (the base script), use exactly eval "$_generating_variable_name".
#
# To embed the macro or activate the function in a generatED script
# simply include $_generating_variable_name.
#
# In either case, the functions generated can be utilized in the usual manner.
#======================================================================
_Make_Absolute_Path_Commands='
#======================================================================
#  This snippet of script was created by inclusion of _Make_Absolute_Path_Commands
#  variable.  Which is defined in the configure script
#======================================================================
for com in cat echo grep ln ls mkdir rm sed wc
do
    if test -x /bin/$com
    then
        cmd=/bin/$com
    elif test -x /usr/bin/$com
    then
        cmd=/usr/bin/$com
    else
        cmd=$com
    fi
    eval $com=$cmd
done
unset com
unset cmd
#======================================================================
#             End of code generated by _Make_Absolute_Path_Commands
#======================================================================'

#======================================================================
#	The following generates the Write_Test function
#======================================================================
_Make_Write_Test='
Write_Test()
{
#======================================================================
#			Write_Test
#
# This function tests for permission to write in the specified
# directory in the most primitive manner.  It first attempts
# to write in the directory, then checks to see it the file
# appears.  This is not the most efficient method, but was 
# the only choice for portability to those systems for which
# no other reliable method exists. 
#
# There is some knowledge of AFS read-only volume replication 
# and the read/write space naming convention at Fermilab.
#
# The function takes two arguments:
#
#	The name of the variable to take, the possibly
#	updated directory value.
#
#	The directory to be tested.
#======================================================================

dir=$2
#======================================================================
# Does the directory exist?
# Attempt to create if it does not.
# Fail with message if unable
#======================================================================
x=$dir
if test ! -d $dir
then
    $mkdir -p $dir 2> /dev/null
    if test ! -d $dir 
    then
        if test x`echo $dir|cut -c6` != x"."
        then
            x=`echo $dir|$sed "s%^/afs/%/afs/.%"`
            x=`echo $x|$sed "s%^/afs/.fnal/%/afs/.fnal.gov/%"`
        fi
    fi
fi
if test $dir != $x
then
    if test ! -d $x
    then
        $mkdir  -p $x 2> /dev/null
    fi
    if test ! -d $x
    then
        echo "    " Unable to create $dir
        echo "    " Terminating
        exit 1
    fi
fi
dir=$x
#======================================================================
# The directory exists.  Proceed with the write test itself
#======================================================================
$rm -f $dir/.Write_Test
$echo $UPS_PROD_NAME $UPS_PROD_VERSION > $dir/.Write_Test 2> /dev/null
if test ! -f $dir/.Write_Test
then
    $rm -f $dir/.Write_Test
    if test `echo $dir|cut -c6` != "."
    then
        x=`echo $dir|$sed "s%^/afs/%/afs/.%"`
        x=`echo $x|$sed "s%^/afs/.fnal/%/afs/.fnal.gov/%"`
        dir=$x
    fi
    $echo $UPS_PROD_NAME $UPS_PROD_VERSION > $dir/.Write_Test
    if test ! -f $dir/.Write_Test
    then
        echo "    " ERROR: Cannot write to $dir
        echo "    " Terminating
        $rm -f $dir/.Write_Test
        exit 1
    fi
fi
#======================================================================
#  It was written.  Can it be removed?
#======================================================================
$rm -f $dir/.Write_Test
if test -f $dir/.Write_Test
then
    echo "  " WARNING:  Unable to remove files from $dir
    echo "  " Operation MAY fail --- Continuing
fi
eval $1=$dir
chmod +rx $dir
unset dir x
}'

#======================================================================
#	Generate the Write_Test function for use in configure
# NOTE:  This is unique because the string is defined at this level.
#        All other uses are simple references.
#======================================================================
eval "$_Make_Write_Test"

#======================================================================
# The following generates the Setups_Dir_Resolve function
#======================================================================
_Make_Setups_Dir_Resolve='
Setups_Dir_Resolve()
{
#======================================================================
#  This function activated by inclusion of reference to _Make_Setups_Dir_Resolve
#  which is defined in the configure script.
#
#  USAGE:
#
#	Setups_Dir_Resolve Variable_Name Reference_to_be_Resolved
#
#  Where:
#
#	Variable_Name is the name of the SHELL variable to which
#	the resolved path name will be assigned.
#
#	Reference_to_be_Resolved is the path reference which is to
#	be resolved and assigned to Variable_Name. 
#======================================================================
    TeMp=${TMPDIR:-/tmp}
    for shell in bash ksh ash sh
    do
        if test -x /bin/$shell
        then
            AsH=/bin/$shell
            break
        elif test -x /usr/bin/$shell
        then
            AsH=/usr/bin/$shell
            break
        fi
    done
    rm -f $TeMp/ASH$$
    $sed "s%        %%" <<AEoFx >$TeMp/ASH$$
        #!$AsH
        eval Res_dir=\$2
        ${echo} \$Res_dir
AEoFx
    chmod +x $TeMp/ASH$$
    eval $1=`$TeMp/ASH$$ $1 $2`
    rm -f $TeMp/ASH$$;
}'

#======================================================================
# Generate the Setups_Dir_Resolve function for use at the configure level
# NOTE:  This is unique because the string is defined at this level.
#        All other uses are simple references.
#======================================================================

eval "$_Make_Setups_Dir_Resolve"

#======================================================================
# Generator for the Copy_If_Changed function
#======================================================================
_Make_Copy_If_Changed='
Copy_If_Changed()
{
#======================================================================
# The Copy_If_Changed function is generated by reference
# to _Make_Copy_If_Changed. If the file to be copied is
# different from the existing file, the existing file is
# copied to a backup and the file is then copied.
#
# Usage
#
#        Copy_If_Changed Infile Outfile
#
#        Infile is the name of the file to be copied
#        qualified sufficiently to identify the file.
#
#        Outfile is the file to be produced also
#        qualified sufficiently to identify the file.
#======================================================================
Infile=$1
Outfile=$2
err=0
Diff_Rc="0"
if test  ! -f $Outfile
then
    Diff_Rc="1"
else
    diff  -b $Outfile $Infile >/dev/null
    Diff_Rc=$?
fi
if test $Diff_Rc != 0
then
    if test -f $Outfile
    then
        cp -p $Outfile $Outfile.BAK
    fi
    echo "++" Copying $Infile to $Outfile
    cp $Infile $Outfile
    if test $? != '0'
    then
        err=1
        echo "++++" An error has prevented the copy of
        echo "++++" $Infile to
        echo "++++" $Outfile
    else
        chmod +rx $Outfile
    fi
else
    echo "++" $Infile identical to $Outfile - not copied.
fi
unset Infile
unset Outfile
test $err = 0
unset err
}'

#======================================================================
# Generator for Keyword_Parse function
#======================================================================
_Make_Keyword_Parse='
Keyword_Parse()
{
# This function parses the value of the keyword from the file. It is 
# assumed that the file consists of comments, and keyword=value lines.
# The keyword matching is case insensitive.  Spaces are ignored.
#
# Usage:
#
#        retrieve the output from "Keyword_Parse keyword file"
#
#        where
#
#             Keyword is the string which is the keyword to be
#             searched for.
#
#             file is the name of the file to be searched qualified
#             sufficiently to identify it.
#
#======================================================================

if test -f $2
then
    while read string
    do
        keyw=`echo $string|$grep -v \#|cut -f1 -d "="|$grep -i $1|$sed "s% %%g"`
        if test x${keyw:-} != x
        then
            echo `echo $string|cut -f2 -d\=|$sed "s% %%g"`
            break
        fi
    done < $2
fi
echo ""
unset keyw
}'
#======================================================================
# Generate the Keyword_Parse function for use at the configure level
# NOTE:  This is unique because the string is defined at this level.
#        All other uses are simple references.
#======================================================================

eval "$_Make_Keyword_Parse"

#Setups_Products_Init_Default="\${Node}/products/ups_database \
#				/usr/products/ups_database \
#				/afs/fnal/ups/db"

# ===  DO NOT EDIT BELOW THIS LINE  ===  DO NOT REMOVE THIS LINE ===

#======================================================================
# Make full path variables for each command in list
# NOTE:  This is unique because the string is defined at this level.
#        All other uses are simple references.
#======================================================================
eval "$_Make_Absolute_Path_Commands"

if test x${Test_Prod_Dir:-} != x
then
    Ups_Dir=$Test_Prod_Dir
fi

error=0
if test x${Ups_Dir:-} = x
then
    echo UPS_PROD_DIR not set.  Configure exiting.
    error=1
fi

if test x${Name_Of_Ups:-} = x
then
    echo UPS_PROD_NAME not set. Configure exiting.
    error=1
fi

if test x${UPS_PROD_FLAVOR:-} = x
then
    echo UPS_PROD_FLAVOR not set. Configure exiting.
    error=1
fi

if test x${UPS_PROD_VERSION:-} = x
then
    echo UPS_PROD_VERSION not set.  Configure exiting.
    error=1
fi

if test x${Ups_DB_Path:-} = x
then
    echo Ups_DB_Path not set. Configure exiting.
    error=1
fi

Make_AFS_ReadWrite() {
   eval _x=\"\$$1\"
   eval ${1}_Read=\"\$$1\"
   eval $1=\"`eval echo $_x |
		sed -e 's;/afs/fnal.gov;/afs/.fnal.gov/;'`\"
}

Make_AFS_ReadWrite Ups_DB_Path

if test $error = 1
then
    exit 1
fi
b_slash='\'
Node=`uname -n|cut -f1 -d'.'`

BootStrap_Dir=$Ups_DB_Path/.upsfiles/configure/${UPS_PROD_VERSION}_${UPS_PROD_FLAVOR}_${UPS_PROD_QUALIFIERS:-}

#======================================================================
# Parse the SETUPS_PATH from the dbconfig file
#======================================================================

Setups_Home=`Keyword_Parse $Setups_Flag $Ups_DB_Path/.upsfiles/dbconfig|$sed 's% %%g'`

if test x${Setups_Home:-} = x
then
    echo '**' $Setups_Flag not defined in $Ups_DB_Path/.upsfiles/dbconfig
    echo '**' Configure cannot continue.
    exit 1
else
    echo '**' $Setups_Flag defined as $Setups_Home in 
    echo '**' $Ups_DB_Path/.upsfiles/dbconfig
fi

Make_AFS_ReadWrite Setups_Home

Setups_Products_List_Home=$Setups_Home

if test `echo $Setups_Home|cut -c1` != '/'
then
    Setups_Dir_Resolve Setups_Products_List_Home $Setups_Home
fi

if test ! -f $Setups_Products_List_Home/$Setups_Products_Init_File
then
    echo '****' $Setups_Products_List_Home/$Setups_Products_Init_File does not exist
    echo '****' Ups cannot be configured.
    echo '-------------------------------'
    echo Please copy $UPS_PROD_DIR/ups/$Setups_Products_Init_File.template
    echo to $Setups_Home/$Setups_Products_Init_File 
    echo and edit it as appropriate before reconfiguring ups.
    exit 1
fi

#======================================================================
# determine the location for the startup and shutdown files.
# The startup and shutdown scripts need not live in the same
# directory as the startup and shutdown lists.
#======================================================================

Startup_Home=${Ups_DB_Path}/.upsfiles

Configure_Date=`date`

Write_Test BootStrap_Dir $BootStrap_Dir

type_test=x`ls -l /usr/local/bin/funame 2>/dev/null|cut -c1-10|$sed 's% %%g'|cut -c1`
if test $type_test = 'xl'
then
    echo ''
    echo '**' WARNING: Please ensure that /usr/local/bin/funame is linked
    echo '**           to' $UPS_PROD_DIR/bin/funame
    echo ''
elif test $type_test != 'x'
then
    echo ''
    echo '**' WARNING: Please convert /usr/local/bin/funame to become a symbolic link
    echo '**           to' $UPS_PROD_DIR/bin/funame
    echo ''
fi
type_Test=x`ls -l /usr/local/bin/dropit 2>/dev/null|cut -c1-10|$sed 's% %%g'|cut -c1`
if test $type_test = 'xl'
then
    echo ''
    echo '**' WARNING: Please ensure that /usr/local/bin/dropit is linked
    echo '**           to' $UPS_PROD_DIR/bin/dropit
    echo ''
elif test $type_test != 'x'
then
    echo ''
    echo '**' WARNING: Please convert /usr/local/bin/dropit to become a symbolic link
    echo '**           to' $UPS_PROD_DIR/bin/dropit
    echo ''
fi
#
#======================================================================
# Create the local copy of the cache file.
# This file MUST be a fresh copy to avoid complications.
#======================================================================
if test -f $BootStrap_Dir/set${Name_Of_Ups}.cache.${UPS_PROD_FLAVOR}
then
    $rm -f $BootStrap_Dir/set${Name_Of_Ups}.cache.${UPS_PROD_FLAVOR}
    if test -f $BootStrap_Dir/set${Name_Of_Ups}.cache.${UPS_PROD_FLAVOR}
    then
	echo '****' Unable to replace cache file in $BootStrap_Dir.
	echo '****' Existing copy could not be removed.
	echo '****' $Name_Of_Ups configure failure.
	exit 1
    fi
fi
$sed 's%^	%%' <<XEoF >$BootStrap_Dir/set${Name_Of_Ups}.cache.${UPS_PROD_FLAVOR}
	#======================================================================
	# This file was created when ${Name_Of_Ups} ${UPS_PROD_VERSION} 
	# was configured on $Node.
	# ${Configure_Date}
	#======================================================================
	$UPS_PROD_DIR
XEoF

chmod +rx $BootStrap_Dir/set${Name_Of_Ups}.cache.${UPS_PROD_FLAVOR}

#
$rm -f $BootStrap_Dir/$Setups_Products_Script
echo '**' Creating $BootStrap_Dir/$Setups_Products_Script
#======================================================================
# Create the script to create PRODUCTS.  
#======================================================================
$sed 's%	%%' <<XEoF >$BootStrap_Dir/$Setups_Products_Script 
	#!/bin/sh
	$URA_Disclaimer
	#======================================================================
	# The $Setups_Products_Script script uses the information in the 
	# $Setups_Home/$Setups_Products_Init_File which was 
	# edited when $Name_Of_Ups database was established, if present.  
	# If this information is missing, the $Setups_Products_Script 
	# will default to a string created when $Name_Of_Ups was configured.
	# This may not be entirely suitable in all cases.
	#
	# This script was generated when $Name_Of_Ups was configured.
	#
# 	Setups_Commands=$Setups_Commands

	BootStrap_Dir=$BootStrap_Dir_Read

	Products_String_File=$Setups_Products_Init_File

	#Setups_Products_Init_Default="$Setups_Products_Init_Default"

	# =====  DO NOT EDIT BELOW THIS LINE  ===  DO NOT REMOVE THIS LINE  =====

	$_Make_Setups_Dir_Resolve

	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================
	$_Make_Absolute_Path_Commands

	if test \`echo \$Setups_Home|cut -c1\` != '/'
	then
	    Setups_Dir_Resolve Setups_Home \$Setups_Home
	fi

	Products_List_Home=\$Setups_Home

	Setups_Current=0

	if test \$Setups_Current = 0
	then
	    Setups_Home=\$BootStrap_Dir
	fi

	#======================================================================
	# Define the node variables.  They're all the same, in case the user goofs.
	#======================================================================
	Node=\`uname -n|cut -f1 -d'.'\`
	node=\$Node; NODE=\$Node
	#======================================================================
	# Find one of the PRODUCTS strings.  There should be several copies.
	# the one in $Setups_Home is preferred.
	# Other wise use the default created at configure time.
	#======================================================================
	if test -r \$Products_List_Home/\$Products_String_File
	then
	    Products_String=\`\$cat \$Products_List_Home/\$Products_String_File|\$grep -v '^#'\`
	    Products_String="\${UPS_EXTRA_DIR} \${Products_String}"
	else
	    echo \$Products_List_Home/\$Products_String_File not found.
	    echo ups was not properly configured.
	    exit 1 
	fi
	#======================================================================
	# Search the PRODUCTS string for existing directories.  They only 
	# count if they exist.  Format the result as a UPSII PRODUCTS
	# environment variable.
	#======================================================================
	prod_set=no
	for Prod in \${Products_String}
	do
	    TeMp=\${TMPDIR:-/tmp}
	    if test \`echo \$Prod|cut -c1\` != '/'
	    then
		Setups_Dir_Resolve Prod \$Prod
	    fi
	    if test -d \$Prod
	    then
		if test \$prod_set = no
	        then
		    PRODUCTS=\$Prod
		    prod_set=yes
	
        	elif test \`echo :\$PRODUCTS:|\$grep -c :\$Prod:\` = "0"
	        then
		    PRODUCTS=\${PRODUCTS}:\${Prod}
		fi
	    fi
	done
	#======================================================================
	# output the result as an eval string which will set the PRODUCTS environment
	# variable in the invoking shell.  NOTE: this is shell family sensitive.
	#======================================================================
	if test x\`echo \${PRODUCTS:-}|cut -c1\` = x/
	then
	    if test \$UPS_SHELL = sh
	    then
	        \$echo PRODUCTS=\$PRODUCTS 
		\$echo export PRODUCTS;
	    elif test \$UPS_SHELL = csh
	    then
	        \$echo setenv PRODUCTS "\$PRODUCTS";
	    fi
	fi
XEoF
#======================================================================
# End of the creation of the PRODUCTS script
#
# Make it executable.
#======================================================================
chmod +x $BootStrap_Dir/$Setups_Products_Script
#
#======================================================================
# Create the setups.pl, ups.pm, setups.py, ups.py files in the bootstrap directory.
#======================================================================
# These are done differently, since they only needs ${Setups_Home} 
# replaced, and use setups.sh...
sed -e "s;\${Setups_Home};${Setups_Home};g" < $UPS_UPS_DIR/${Script_Prefix}.pl > ${BootStrap_Dir}/${Script_Prefix}.pl
sed -e "s;\${Setups_Home};${Setups_Home};g" < $UPS_UPS_DIR/ups.pm > ${BootStrap_Dir}/ups.pm
sed -e "s;\${Setups_Home};${Setups_Home};g" < $UPS_UPS_DIR/ups.py > ${BootStrap_Dir}/ups.py
sed -e "s;\${Setups_Home};${Setups_Home};g" < $UPS_UPS_DIR/${Script_Prefix}.py > ${BootStrap_Dir}/${Script_Prefix}.py

#
#======================================================================
# Create the setups.csh file in the bootstrap directory.
#======================================================================
$rm  -f $BootStrap_Dir/${Script_Prefix}.csh
echo '**' Creating $BootStrap_Dir/${Script_Prefix}.csh
$sed 's%^	%%' <<XEoF >$BootStrap_Dir/${Script_Prefix}.csh
	#!/bin/csh
	$URA_Disclaimer

	#======================================================================
	# The ${Script_Prefix}.csh script is designed to be sourced at shell invocation
	# including the time of login.  It uses several other scripts located
	# in $Setups_Home to determine the 
	# PRODUCTS and UPS_DIR environment variables. 
	#
	# This script is sourced by the fermi.csh files to bootstrap the
	# ups working environment and aliases.
	# If you need to reestablish missing aliases in a subshell process,
	# use the following code:
	#    source \`\${UPS_DIR}/bin/ups setup ups\`
	# 
	# This script and all the scripts utilized are created when a version 
	# of $Name_Of_Ups is configured.
	#
	# The scripts utilized by the ${Script_Prefix}.csh script are:
	# 
	#    $Setups_Home/$Setups_Products_Script
	#
	#    $Setups_Home/${Script_Prefix}.common,
	#     as a last resort.
	#
	#    $Setups_Home/set${Name_Of_Ups}.cache.'<flavor>' 
	#    is used to determine the UPS_DIR variable.
	#======================================================================

	set Setups_Home=$Setups_Home_Read

	set BootStrap_Dir=$BootStrap_Dir_Read

	# =====  DO NOT EDIT BELOW THIS LINE  ===  DO NOT REMOVE THIS LINE =====

	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================

	foreach com ($Setups_Commands)
	    if ( -x /bin/\$com ) then
		set cmd=/bin/\$com
	    else if ( -x /usr/bin/\$com ) then
		set cmd=/usr/bin/\$com
	    else
		set cmd=\$com
	    endif

	    eval set \$com=\$cmd
	end
	unset cmd
	unset com

	#======================================================================
	# Check on the status of /bin/sh which is needed for completion
	#======================================================================

	set error=0
	set binstat=\`\$ls -1 /bin|\$wc -w|\$sed "s% %%g"\`
	if ( ! -d /bin ) then
	    echo ERROR - The /bin directory does not exist.
	    echo "      " It may only need to be mounted.
	    set error=1
	else if ( \$binstat == 0 ) then
	    echo ERROR - The /bin directory is empty.
	    echo "      " This is a fatal condition
	    echo "      " Contact the system administrator.
	    set error=1
	else if ( ! -x /bin/sh ) then
	    echo ERROR - The bourne shell - /bin/sh - does not exist.
	    echo "      " Ups cannot be set up until this is corrected.
	    echo "      " Contact the system administrator.
	    set error=1
	endif
	unset binstat

	set Setups_Current=0
	if ( \$Setups_Current == 0 ) then
	    set Setups_Home=\$BootStrap_Dir
	endif

	eval setenv SETUPS_DIR \$Setups_Home

	eval setenv Setups_Home \$Setups_Home

	set Name_Of_Ups=$Name_Of_Ups
	setenv UPS_SHELL csh
	#======================================================================
	# Determine probable flavor names for the version of $Name_Of_Ups
	# which would execute on this platform.
	#======================================================================
	set Node=\`uname -n|cut -f1 -d'.'\`
	unset MACH_OS
	if ( \$?UPS_OVERRIDE ) then
	    setenv MACH_OS "\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ +]*\\)+.*/\\1/'\`"
	    set Full_Flavor="\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ ]*\\).*/\\1/'\`"

	else if ( -r \$SETUPS_DIR/ups_override.\$Node ) then
	    setenv UPS_OVERRIDE "\`cat \$SETUPS_DIR/ups_override.\$Node\`"
	    setenv MACH_OS "\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ +]*\\)+.*/\\1/'\`"
	    set Full_Flavor="\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ ]*\\).*/\\1/'\`"

	else
	    setenv MACH_OS "\`uname -s\`"
	    set mach=\`echo \$MACH_OS|cut -c1-4\`
	    if ( \$mach == IRIX ) setenv MACH_OS IRIX
	    if ( \$mach == CYGW ) setenv MACH_OS CYGWIN32_NT
	    set Full_Flavor="\$MACH_OS"'+'\`uname -r|sed -e 's/[ ()].*//'\`'.'\`uname -v|sed -e 's/[ ()].*//'\`
	    if ( "\$MACH_OS" == AIX ) set Full_Flavor="\$MACH_OS"'+'\`uname -v\`'.'\`uname -r\`
	    if ( "\$MACH_OS" == Linux ) then
                set Trailer="\`uname -r|sed -e 's/[ ()].*//'\`"
                set Full_Flavor="\${MACH_OS}+\${Trailer}"
            endif
	    if ( `uname -m` == "PPC" && "\$MACH_OS" == "Linux" ) set Full_Flavor="\$MACH_OS"\`uname -m\`'+'\`uname -v\`'.'\`uname -r|sed -e 's/[ ()].*//'\`
	    if ( "\$MACH_OS" == CYGWIN32_NT ) set Full_Flavor="\$MACH_OS"'+'\`uname -r|sed -e 's/[ ()].*//'\`
	endif

	#======================================================================
	# Determine the unique set of possible flavors
	#======================================================================
	set Flavor=\`echo \$Full_Flavor|cut -f1 -d'.'\`
	foreach level (2 3 4 5 6 7 8 9)
	    set fl="\`echo \$Full_Flavor|cut -f1-\$level -d'.'\`"
	    if ( "\$fl" != "\$Full_Flavor" ) then
		set Flavor_\$level="\$fl"
	    else
		set Flavor_\$level=''
	    endif
	end
	set No_SETUP_UPS=0

	if ( \$error == 0 && \$?UPS_DIR ) then
	    if ( x\`echo \$UPS_DIR|cut -c1\` != x/ ) then
	        unsetenv UPS_DIR
	        unset UPS_DIR
		unsetenv SETUP_UPS
	    else
		if ( \$?SETUP_UPS ) then
		    set Ups_Flavor=''
		    foreach field ( 2 3 4 5 6 7 8 )
			set f1=\`echo \$SETUP_UPS|cut -f\${field} -d '-'\`
			if ( "x\$f1" == "x" ) then
			    break
			endif
	 		set fq=\`echo \$f1|cut -c1\`
			if ( x\$fq == xf ) then
			    set Ups_Flavor=\`echo \$f1|cut -f2 -d' '\`
			    break
			endif
		    end
		    set xflav=x\`echo \$Full_Flavor|\$grep \$Ups_Flavor\`
		    if ( \$xflav == x ) then
		        unsetenv UPS_DIR
			set No_SETUP_UPS=1
#		        unsetenv SETUP_UPS
		    endif
		    unset f1
		    unset field
		    unset fq
		    unset Ups_Flavor
		endif
	    endif
	else
	    unsetenv UPS_DIR
	    unset UPS_DIR
	    unsetenv SETUP_UPS
	endif
	#======================================================================
	# Don't trust PRODUCTS if SETUP_UPS is not defined
	#======================================================================
	if ( \$No_SETUP_UPS == 1 || ! \$?SETUP_UPS ) then
	    unset PRODUCTS
	    unsetenv PRODUCTS
	endif
	#======================================================================
	# Define the PRODUCTS variable, if needed
	#======================================================================
	if (  \$error == 0 && ! \$?PRODUCTS ) then
	    if ( -x \${Setups_Home}/$Setups_Products_Script ) then
	        eval \`\${Setups_Home}/$Setups_Products_Script\`
	    endif
	endif
	#======================================================================
	# Attempt to determine the file name of the cached ups information from the 
	# naming convention and the probable flavors which might execute correctly
	# on the platform executing this script.  If found, utilize it to define
	# a usable UPS_DIR.
	#======================================================================
	if ( \$?PRODUCTS && ! \$?UPS_DIR ) then
	    foreach fl ( "\$Node" "\$Full_Flavor" "\$Flavor_9" "\$Flavor_8" "\$Flavor_7" "\$Flavor_6" "\$Flavor_5" "\$Flavor_4" "\$Flavor_3" "\$Flavor_2" "\$Flavor" "\$MACH_OS" NULL )
	        if ( -f \${Setups_Home}/set\${Name_Of_Ups}.cache.\${fl} ) then
		    eval setenv UPS_DIR \`\$cat \$Setups_Home/set\${Name_Of_Ups}.cache.\${fl}|\$grep -v '^#'\`
	            if ( \$?UPS_DIR ) then
	               if ( -d \$UPS_DIR ) then
		             break
	                else
	                    unsetenv UPS_DIR
	                endif
	            endif
	        endif
	    end
	endif
	#======================================================================
	# If we have been unsuccessful so far, search the possible products 
	# databases for some $Name_Of_Ups which might execute on the this platform.
	#
	# This process, although thorough, is very time consuming.
	#======================================================================
	if ( \$error == 0 && ! \$?UPS_DIR ) then
	    if ( -x \$Setups_Home/${Script_Prefix}.common ) then
		eval \`\$Setups_Home/${Script_Prefix}.common\`
	    endif
	endif
	#======================================================================
	# If everything failed, report same and return.
	#
	# DO NOT EXIT - this might be the login shell.
	#======================================================================
	if (! \$?UPS_DIR ) then
	    echo '****'
	    echo '**** Unable to initialize the UPSII environment'
	    echo '****'
	else
	#======================================================================
	# If we have successfully managed to find a usable version of $Name_Of_Ups,
	# give this version of $Name_Of_Ups the information  found so far and let it 
	# determine the BEST version.
	#
	# This extra step ensures that the appropriate $Name_Of_Ups search order
	# is followed to arive at the final result.  It also is the step executed
	# even when PRODUCTS and UPS_DIR are known at entry.  The $Name_Of_Ups 
	# setup script may set aliases which are NOT inherited by sub-shells.
	#======================================================================
	    if ( \$No_SETUP_UPS == 0 && \$?SETUP_UPS ) then
		source \`\$UPS_DIR/bin/ups setup \$SETUP_UPS\`
	    else
	        source \`\$UPS_DIR/bin/ups setup \$Name_Of_Ups\`
	    endif
	endif
	#======================================================================
	# Because this is designed to be sourced, it is nice to unset the local
	# shell variables
	#======================================================================
	unset $Setups_Commands Setups_Commands error f1 field Full_Flavor Flavor_2 
	unset Flavor_3 Flavor_4 Flavor_5 Flavor_6 Flavor_7 Flavor_8 Flavor_9
	unset Node NODE node BootStrap_Dir Setups_Current mach fl Flavor Setups_Home 
	unset No_SETUP_UPS Name_of_Ups
	unsetenv Setups_Home
XEoF
#
#======================================================================
# Create the setups.sh script
#======================================================================
$rm -f $BootStrap_Dir/${Script_Prefix}.sh
echo '**' Creating $BootStrap_Dir/${Script_Prefix}.sh
$sed 's%^	%%' <<XEoF >$BootStrap_Dir/${Script_Prefix}.sh
	#!/bin/sh
	$URA_Disclaimer
	#
	#======================================================================
	# The ${Script_Prefix}.sh script is designed to be sourced at shell invocation
	# including the time of login.  It uses several other scripts located in  
	# $Setups_Home to determine the 
	# PRODUCTS and UPS_DIR environment variables.This script and all the 
	# scripts utilized are created when a version of $Name_Of_Ups is configured.

	# This script is sourced by the fermi.sh files to bootstrap the
	# ups working environment and aliases.
	# If you need to reestablish missing aliases in a subshell process,
	# use the following code:
	#    . \`\${UPS_DIR}/bin/ups setup ups\`
	# 
	# NOTE: The '.' in the preceeding line is significant.
	#
	# The scripts utilized by the ${Script_Prefix}.sh script are:
	# 
	#    $Setups_Home/$Setups_Products_Script
	#
	#    $Setups_Home/${Script_Prefix}.common,
	#    as a last resort.
	#
	#    $Setups_Home/set${Name_Of_Ups}.cache.'<flavor>' 
	#    is used to determine the value of UPS_DIR.
	#======================================================================
	#
	# ===		SYS ADMIN AREA		=====
	#
	# The following shell variables are defined here:
	#
	#       Setups_Home
	#
	#       Name_Of_Ups
	#
	# Please check their values and change, if necessary, following
	# their descriptions below.
	#
	#
	# Because the shell languages manage to lose the filename
	# of the file being sourced the Setups_Home variable
	# exists to assist in installing the codes on non Fermilab
	# machines.  Change this to the directory in which the
	# setups.* scripts live.
	#======================================================================
	Setups_Home=$Setups_Home_Read
	#======================================================================
	# Name_Of_Ups should always be ups at Fermilab, unless in beta test
	#======================================================================
	Name_Of_Ups=$Name_Of_Ups

#	Setups_Commands=$Setups_Commands
	
	BootStrap_Dir=$BootStrap_Dir_Read
 	 
	# === DO NOT EDIT BELOW THIS LINE === DO NOT REMOVE THIS LINE ===

	$_Make_Setups_Dir_Resolve


	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================
	$_Make_Absolute_Path_Commands


	#======================================================================
	# Check on the status of /bin/sh which is needed for completion
	#======================================================================

	error=0
	if test ! -d /bin 
	then
	    echo ERROR - The /bin directory does not exist.
	    echo "      " A mount may be required.
	    error=1
	elif test \`\$ls -1 /bin|\$wc -w\` = 0
	then
	    echo ERROR - The /bin directory is empty.
	    echo "      " This is a fatal condition
	    echo "      " Contact the system administrator.
	    error=1
	elif test ! -x /bin/sh 
	then
	    echo ERROR - The bourne shell - /bin/sh - does not exist.
	    echo "      " Ups cannot be set up until this is corrected.
	    echo "      " Contact the system administrator.
	    error=1
	fi

	if test \`echo \$Setups_Home|cut -c1\` != '/'
	then

	    Setups_Dir_Resolve Setups_Home \$Setups_Home
	fi
	
	export Setups_Home

	Setups_Current=0
	
	if test \$Setups_Current = 0
	then
	    Setups_Home=\$BootStrap_Dir
	fi

	SETUPS_DIR=\$Setups_Home; export SETUPS_DIR

	UPS_SHELL=sh; export UPS_SHELL
	
	#======================================================================
	# Determine probable flavor names for the version of $Name_Of_Ups
	# which would execute on this platform.
	#======================================================================
	Node=\`uname -n|cut -f1 -d'.'\`
	MACH_OS=\`uname -s\`

	if test "\${UPS_OVERRIDE:-x}" != x
	then
	    MACH_OS=\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ +]*\\)+.*/\\1/'\`
	    Full_Flavor=\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ ]*\\).*/\\1/'\`

	elif test -r \$SETUPS_DIR/ups_override.\$Node
	then
	    UPS_OVERRIDE=\`cat \$SETUPS_DIR/ups_override.\$Node\`
	    export UPS_OVERRIDE
	    MACH_OS=\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ +]*\\)+.*/\\1/'\`
	    Full_Flavor=\`echo \$UPS_OVERRIDE | sed -e 's/.*-H \\([^ ]*\\).*/\\1/'\`

	else
	    if test "\`echo \$MACH_OS|cut -c1-4\`" = IRIX
	    then
		MACH_OS=IRIX
	    fi
	    if test "\`echo \$MACH_OS|cut -c1-4\`" = CYGW
	    then
		MACH_OS=CYGWIN32_NT
	    fi
	    export MACH_OS
	    Full_Flavor="\$MACH_OS"'+'\`uname -r|sed -e 's/[ ()].*//'\`'.'\`uname -v|sed -e 's/[ ()].*//'\`
	    if test "\$MACH_OS" = AIX
	    then
		Full_Flavor="\$MACH_OS"'+'\`uname -v\`'.'\`uname -r\`
	    fi
	    if test "\$MACH_OS" = Linux -o "\$MACH_OS" = CYGWIN32_NT
	    then
		Full_Flavor="\$MACH_OS"'+'\`uname -r|sed -e 's/[ ()].*//'\`
	    fi
	    if test `uname -m` = "PPC" -a "\$MACH_OS" = "Linux" 
            then 
		Full_Flavor="\$MACH_OS"\`uname -m\`'+'\`uname -v\`'.'\`uname -r|sed -e 's/[ ()].*//'\`
	    fi
	fi
	for level in 2 3 4 5 6 7 8 9
	do
	    fl=\`echo \$Full_Flavor|cut -f1-\$level -d'.'\`
	    if test "\$fl" != "\$Full_Flavor"
	    then
		eval Flavor_\$level=\$fl
	    else
		eval Flavor_\$level=''
	    fi
	done
	Flavor=\`echo \$Full_Flavor | cut -f1 -d'.'\`
	No_SETUP_UPS=0
	if test \$error = 0 -a x\`echo \${UPS_DIR:-x}|cut -c1\` = x/
	then
	    if test ! -d \$UPS_DIR
	    then
		unset UPS_DIR
	    fi
	    if test "\${SETUP_UPS:-x}" != x
	    	then
		for field in 2 3 4 5 6 7 8
		do
		    f1=\`echo \$SETUP_UPS|cut -f\${field} -d'-'\`
		    if test "\${f1:-x}" = "x"
		    then
			break
		    fi
		    if test \`echo \$f1|cut -c1\` = f
		    then
			Ups_Flavor=\`echo \$f1|cut -f2 -d' '\`
			break
		    fi
		done
	
		if test x\`echo \$Full_Flavor | \$grep \${Ups_Flavor:-} 2>/dev/null\` = x
		then
		    unset UPS_DIR
		    No_SETUP_UPS=1
#		    unset SETUP_UPS
		fi
		unset f1
		unset Ups_Flavor
	    fi
	else
		unset UPS_DIR
	fi
	#====================================================================== 
	# Don't trust the PRODUCTS variable if SETUP_UPS is not defined
	#======================================================================
	if test \$No_SETUP_UPS = 1 -o x = "\${SETUP_UPS:-x}"
	then
	    unset PRODUCTS
	fi
	#======================================================================
	# Attempt to define the PRODUCTS variable.
	#======================================================================
	if test \$error = 0 -a x\`echo \${PRODUCTS:-}|cut -c1\` != x/
	then
	    if test -x \${Setups_Home}/$Setups_Products_Script 
	    then
	        eval \`(unset ENV;\${Setups_Home}/$Setups_Products_Script)\`
	    fi   
	fi
	#======================================================================
	# Attempt to determine the file name of the cached ups information from the 
	# naming convention and the probable flavors which might execute correctly
	# on the platform executing this script.  If found, utilize it to define
	# a UPS_DIR.
	#======================================================================
	if test x\`echo \${PRODUCTS:-}|cut -c1\` = x/ -a \${UPS_DIR:-x} = x
	then
	    for fl in "\$Node" "\$Full_Flavor" "\$Flavor_9" "\$Flavor_8" "\$Flavor_7" "\$Flavor_6" "\$Flavor_5" "\$Flavor_4" "\$Flavor_3" "\$Flavor_2" "\$Flavor" "\$MACH_OS" NULL
	    do
	        if test -f \$Setups_Home/set\${Name_Of_Ups}.cache.\${fl}
	        then
	            UPS_DIR=\`\$cat \$Setups_Home/set\${Name_Of_Ups}.cache.\${fl}|\$grep -v '^#'\`
	        fi
	        if test \${UPS_DIR:-x} != x
	        then
	            if test -d \$UPS_DIR
	            then
	                break
	            else
	                unset UPS_DIR
	            fi
	        fi
	   done
	fi
	#======================================================================
	# If we have been unsuccessful so far, search the possible products 
	# databases for some $Name_Of_Ups which might execute on this platform.
	#
	# This process, although thorough, is very time consuming.
	#======================================================================
	if test \$error = 0 -a \${UPS_DIR:-x} = x
	then
	    if test -x \$Setups_Home/${Script_Prefix}.common
	    then
	        eval \`(unset ENV;\$Setups_Home/${Script_Prefix}.common sh)\`
	    fi
	fi
	if test \${UPS_DIR:-x} != x
	then
	#======================================================================
	# If we have successfully managed to find a usable version of $Name_Of_Ups,
	# give this version of $Name_Of_Ups the information  found so far and let it 
	# determine the BEST version.
	#
	# This extra step ensures that the appropriate $Name_Of_Ups search order is
	# followed to arive at the final result.  It also is the step executed even
	# when PRODUCTS and UPS_DIR are known at entry.  The $Name_Of_Ups setup script
	# may define functions which are NOT inherited by sub-shells.
	#======================================================================
	    if test \$No_SETUP_UPS = 0 -a "\${SETUP_UPS:-x}" != x
	    then
		. \`\$UPS_DIR/bin/ups setup \$SETUP_UPS\`
	    else
		. \`\$UPS_DIR/bin/ups setup \$Name_Of_Ups\`
	    fi
	else
	#======================================================================
	# If everything failed, report same and return.
	#
	# DO NOT EXIT - this might be the login shell.
	#======================================================================
		echo '****'
		echo '**** Unable to initialize UPSII environment'
		echo '****'
	fi
	#======================================================================
	# Because this is designed to be "sourced", its nice to unset the shell
	# variables.
	#======================================================================
	unset $Setups_Commands Setups_Commands error f1 field Full_Flavor Flavor_2 
	unset Flavor_3 Flavor_4 Flavor_5 Flavor_6 Flavor_7 Flavor_8 Flavor_9
	unset No_SETUP_UPS
	unset Node BootStrap_Dir Setups_Current fl Flavor Setups_Home Name_Of_Ups
	# OSF1 /bin/sh leaves /tmp/shNNNNN files if you unset functions
	if [ "\$MACH_OS" != OSF1 ] 
	then
	   unset Setups_Dir_Resolve
	fi

XEoF
#======================================================================
# End of the creation of the setups.sh script.  
#======================================================================
#
#======================================================================
# Create the startup and shutdown scripts.
#======================================================================
 
Boot_Start='yes'
for Start_Or_Stop in startup shutdown
    do
    $rm -f $BootStrap_Dir/ups_${Start_Or_Stop}
    echo '**' Creating $BootStrap_Dir/ups_${Start_Or_Stop}
    $sed 's%^	%%' <<XEoF >$BootStrap_Dir/ups_${Start_Or_Stop}
	#!/bin/sh
	#
	$URA_Disclaimer
	#
	# The primary functionality of the $Start_Or_Stop script is to provide the
	# basic ups environment for the products which will be started as a
	# result of executing the appropriate file.  No attempt is made to
	# determine that the file being sourced is appropriate in other then
	# name.
	#
	# The algorithm employed here looks in the PRODUCTS environment
	# variable for directories of the form /.../.upsfiles/${Start_Or_Stop},
	# /.../${Start_Or_Stop}, or /.../../${Start_Or_Stop} for ${Start_Or_Stop} files of the
	# form \$Node.products or \$MACH_OS.products.  Where \$Node is the
	# unqualified name of the machine on which the script is executing and 
	# \$MACH_OS is the base level operating system name as returned by uname -s.  
	#
	# Only the first such file is sourced from the first directory in which 
	# one is found. 
	#
	# The $Start_Or_Stop script was generated when $Name_Of_Ups was configured.
	#======================================================================

	Script_Prefix=$Script_Prefix

	Setups_Home=$Setups_Home_Read

	Ups_DB_Path=$Ups_DB_Path_Read

#	Setups_Commands=$Setups_Commands

	BootStrap_Dir=$BootStrap_Dir_Read

	Setup_List=${Ups_DB_Path}/.upsfiles/${Start_Or_Stop}

	# ===== DO NOT EDIT BELOW THIS LINE  ====  DO NOT REMOVE THIS LINE ====

	$_Make_Setups_Dir_Resolve

	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================

	$_Make_Absolute_Path_Commands

	Setups_Current=0

	if test \$Setups_Current = 0
	then
	    Setups_Home=\$BootStrap_Dir
	fi

	if test \`echo \$Setups_Home|cut -c1\` != '/'
	then
	    Setups_Dir_Resolve Setups_Home \$Setups_Home
	fi

	#======================================================================
	# set the appropriate environmental variables for root 
	#======================================================================
	if test x\${PATH:-} != x
	then
	    PATH=\$PATH:/bin:/usr/bin
	else
	    PATH=/bin:/usr/bin
	fi
	if test ! -f \$Setups_Home/\${Script_Prefix}.sh
	then
	    echo '****' \$Name_Of_Ups initialization file 
	    echo '****' \$Setups_Home/\${Script_Prefix}.sh not found
	    exit 1
	else	
	    . \$Setups_Home/\${Script_Prefix}.sh
	fi
                                              
	Node=\`uname -n|cut -f1 -d'.'\`               
                                              
	MACH_OS="\`uname -s\`"
	if test "\`echo \$MACH_OS|cut -c1-4\`" = IRIX    
	then                                          
	    MACH_OS=IRIX                              
	fi                                            
	Full_Flavor="\$MACH_OS"'+'\`uname -r\`
	if test "\$MACH_OS" = AIX
	then
	    Full_Flavor="\$MACH_OS"'+'\`uname -v\`'.'\`uname -r\`
	fi
	if test "\$MACH_OS" = Linux
	then
	    Full_Flavor="\$MACH_OS"'+'\`uname -r\`
	fi
	for level in 2 3 4 5 6 7 8 9
	do
	    fl=\`echo \$Full_Flavor|cut -f1-\$level -d'.'\`
	    if test "\$fl" != "\$Full_Flavor"
	    then
	        eval Flavor_\$level=\$fl
	    else
	        eval Flavor_\$level=''
	    fi
	done
	Flavor=\`echo \$Full_Flavor | cut -f1 -d'.'\`

	for starts in \`echo \${PRODUCTS}|tr ':' ' '\`
	do
	    starts_dir=\$starts
	    if test ! -d \$starts_dir
	    then
		continue
	    fi
	    if test -d \$starts/.upsfiles/$Start_Or_Stop
	    then
		starts_dir=\$starts/.upsfiles/$Start_Or_Stop
	    elif test -d \$starts/$Start_Or_Stop
	    then
	        starts_dir=\$starts/$Start_Or_Stop
	    elif test -d \$starts/../$Start_Or_Stop
	    then
	        starts_dir=\$starts/../$Start_Or_Stop
	    fi
	    started='0';
	#======================================================================
	# execute the appropriate node.products or flavor.products file
	#======================================================================
	    for fl in "\$Node" "\$Full_Flavor" "\$Flavor_9" "\$Flavor_8" "\$Flavor_7" "\$Flavor_6" "\$Flavor_5" "\$Flavor_4" "\$Flavor_3" "\$Flavor_2" "\$Flavor" "\$MACH_OS"
	    do
		if test -f \$starts_dir/\$fl.products
		then
		    \$starts_dir/\$fl.products
		    started='1'
		    break
		fi
	    done
	    if test \$started = '1'
	    then
		break
	    fi
	done
	#======================================================================
	# If we made it this far, we found nothing to start
	# Report the fact.
	#======================================================================
	if test \$started = '0'
	then
	    \$echo '****'
	    \$echo '****' No $Start_Or_Stop files were found - nothing done.
	    \$echo '****'
	fi
XEoF
    chmod 0771 $BootStrap_Dir/ups_${Start_Or_Stop}
done
#
#======================================================================
# Create the setups.common.  It is sincerely hoped that 
# this will never be needed.
#
# IT IS  V E R  Y    S   L    O     W
#======================================================================
$rm -f $BootStrap_Dir/${Script_Prefix}.common
echo '**' Creating $BootStrap_Dir/${Script_Prefix}.common
$sed 's%^	%%' <<XEoF > $BootStrap_Dir/${Script_Prefix}.common 
	#!/bin/sh 
	$URA_Disclaimer
	#
	#======================================================================
	# Setups common
	#
	# This is the work-horse of the setupsII family.  The primary
	# function is to determine where the "current" version of ups
	# suitable to be executed on the resident node is located.
	#
	# This file was created by the $Name_Of_Ups configure script when
	# $Name_Of_Ups was installed.
	#
	#
	#
	# ===			SYS ADMIN AREA 			===
	#
	# The following shell variables are defined here:
	#
	#	Setups_Home_Dir
	#
	#	Setups_Product_Init_File
	#
	#	Name_Of_Ups
	#
	# Please check their values and change, if necessary, following 
	# their descriptions below.
	#
	#	
	# Because the shell languages manage to lose the filename
	# of the file being sourced, the Setups_Home_Dir variable
	# exists to assist in installing the codes on non Fermilab
	# machines.  Change this to the directory in which the
	# setups.* scripts live.
	#======================================================================
	
	Setups_Home_Dir=\$Setups_Home

	Setups_Product_Init_File=$Setups_Products_Init_File

	Name_Of_Ups=$Name_Of_Ups

	BootStrap_Dir=$BootStrap_Dir
	#======================================================================
	# The following sets the default value for the product_string.
	# Later logic will attempt to find the value defined when 
	# the database was initialized
	#======================================================================

	#Product_String="$Setups_Products_Init_Default $Ups_DB_Path"

#	Setups_Commands=$Setups_Commands

	#
	# === DO NOT EDIT BELOW THIS LINE === DO NOT REMOVE THIS LINE ===

	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================
	
	$_Make_Absolute_Path_Commands

	Setups_Current=0

	if test \$Setups_Current = 0
	then
	    Setups_Home=\$BootStrap_Dir
	fi

	Shell=\$UPS_SHELL

	Node=\`uname -n|cut -f1 -d'.'\`

	if test -r \$Setups_Home_Dir/\$Setups_Product_Init_File
	then
		Product_String=\`\$cat \$Setups_Home_Dir/\$Setups_Product_Init_File|\$grep -v '^#'\`
	fi
	#======================================================================
	# Determine a likely flavor to search for.  The actual search 
	# should find something useful on this platform.
	#======================================================================
	MACH_OS="\`uname -s\`"
	if test "\`echo \$MACH_OS|cut -c1-4\`" = IRIX
	then
	    MACH_OS=IRIX
	fi
	export MACH_OS
	r=\`uname -r|cut -f1 -d'.'\`
	if test "\$MACH_OS" = AIX
	then
	    r=\`uname -v\`
	fi
	if test "\$MACH_OS" = HP-UX
	then
	    r=\`uname -v|cut -f2 -d'.'\`
	fi
	Flavor_Wanted=\${MACH_OS}+\${r}
	#======================================================================
	# All right.  Now $Name_Of_Ups is still a $Name_Of_Ups product
	# as such it must live in a PRODUCTS database.
	#
	# Find the PRODUCTS databases.
	#======================================================================
	if test "x\`echo \${PRODUCTS:-}|cut -c1\`" != "x/"
	then
	    prodset=no
	    for Prod in \$Product_String
	    do
	        if test -d \$Prod
	        then
		    if test \$prodset = no
	            then
			PRODUCTS=\$Prod
			prodset=yes
	            elif test \`echo :\$PRODUCTS:|\$grep -c :\$Prod:\` = "0"
	            then
	                PRODUCTS="\$PRODUCTS' '\${Prod}"
	            fi
	        fi
	    done
	fi
	#======================================================================
	# Now for the time consuming search of the PRODUCTS for an 
	# appropriate 'current' version of $Name_Of_Ups.
	#======================================================================
	if test "x\`echo \${PRODUCTS:-}|cut -c1\`" = "x/"
	then
	    PRODUCTS=\`echo \$PRODUCTS|tr ':' ' '\`
	    prodset=no
	    for Prod in \${PRODUCTS}
	    do
		if test \$prodset = no
		then
		    Pstr_new=\$Prod
		    prodset=yes
		else
		    Pstr_new="\${Pstr_new}':'\${Prod}"
		fi
	#======================================================================
	# It is legal to declare ups to its database with a relative chain
	# On the off chance that this was done, parse out the PROD_DIR_PREFIX
	# from the dbconfig file.
	#======================================================================
		if test -r \$Prod/.upsfiles/dbconfig
		then
		    Ups_Pre=\`\$grep -i PROD_DIR_PREFIX  \$Prod/.upsfiles/dbconfig|\$grep -v '#'|cut -f2 -d'='|\$sed 's% %%g'\`
		fi
		if test -r \$Prod/\${Name_Of_Ups}/current.chain
		then
		    Parse_curr=\$Prod/\${Name_Of_Ups}/current.chain
		    while read string
		    do	
			key=\`echo \$string|cut -f1 -d'=' -s|tr 'a-z' 'A-Z'|\$sed 's% %%g'\`
			val=\`echo \$string|cut -f2 -d'=' -s|cut -f1 -d'#'|\$sed 's% %%g'\`
			if test x\${val} != x
			then
			    if test "\$key" = "FLAVOR"
			    then
				FLAVOR=\$val
			    elif test "\$key" = "VERSION"
			    then
				VERSION=\$val
			    fi
			fi
			if test x\${VERSION} != x -a x\${FLAVOR} != x
			then
			    if test "\$FLAVOR" = "\$Flavor_Wanted" -o "\$FLAVOR" = "\$MACH_OS"
			    then
				Ups_Version_File=\${VERSION}.version
				Ups_Flavor=\$FLAVOR
				Ups_Version=\$VERSION
				Parse_ver=\$Prod/\${Name_Of_Ups}/\$Ups_Version_File
	        		while read string
	        		do
	            		    key=\`echo \$string|cut -f1 -d'='|tr 'a-z' 'A-Z'|\$sed 's% %%g'\`
	            		    val=\`echo \$string|cut -f2 -d'=' -s|cut -f1 -d'#'|\$sed 's% %%g'\`
	            		    if test "x\${key}" = xFLAVOR
	            		    then
	                		FLAVOR=\$val
	            		    fi
	            		    if test "x\${key}" = xPROD_DIR
	            		    then
	                		PROD_DIR=\$val
	            		    fi
	            		    if test x\${FLAVOR} != x -a x\${PROD_DIR} != x
	            		    then
	                		if test \$FLAVOR = \$Ups_Flavor
	                		then
					    First_C=\`echo \$PROD_DIR|cut -c1\`
					    if test x\${First_C} != "x/"
					    then
						PROD_DIR=\${Ups_Pre}/\${PROD_DIR}
					    fi
					    if test ! -d \$PROD_DIR
					    then
						continue
					    fi
	                    		    UPS_DIR=\$PROD_DIR;export UPS_DIR
					    export PRODUCTS
	    				    if test \$Shell = 'sh'
	    				    then
	        				\$echo UPS_DIR=\$UPS_DIR; export UPS_DIR;
	    				    elif test \$Shell = 'csh'
	    				    then
	        				\$echo setenv UPS_DIR \$UPS_DIR;
	    				    else
	        				\$echo echo '**';
	        				\$echo echo '**' Shell class "\$Shell" unknown;
	        				\$echo echo '**';
					    fi
					    touch /tmp/.__SeTuPs_.\$$
	                    		    break	# exit while read version file
	                		fi
	            		    FLAVOR=''
	            		    PROD_DIR=''
	            		    fi
	        		done < \$Parse_ver
				\$rm -f /tmp/VSeTuPs.\$$
				if test -r /tmp/.__SeTuPs_.\$$
				then
				    break	# exit while read current.chain
				fi
			    fi
			    FLAVOR=''
			    VERSION=''
			fi
		    done < \$Parse_curr
		    \$rm -f /tmp/.SeTuPs.\$$
		    if test -r /tmp/.__SeTuPs_.\$$
		    then
			break	# Exit for Prod
		    fi
	        fi
	    done        # End of for Prod

	\$rm -f /tmp/.__SeTuPs_.\$$
	fi
XEoF
#======================================================================
# End of the creation phase of setups.common
#
# Make setups.common executable
#======================================================================
chmod +x $BootStrap_Dir/${Script_Prefix}.common
#
#======================================================================
#                        U P S   S U B - D I R E C T O R Y
#
# Begin the creation phase for the usual ups scripts
#
# Create the current script
#======================================================================
$rm -f $BootStrap_Dir/current
echo '**' Creating $BootStrap_Dir/current
$sed 's%^	%%' <<XEoF >$BootStrap_Dir/current
	#!/bin/sh
	$URA_Disclaimer
	#
	#======================================================================
	# Current script for $Name_Of_Ups
	#
	# This file is created by the $Name_Of_Ups product configure script.
	#
	# The primary function of this script is to copy the files from 
	# the bootstrap sub-directory of the $Name_Of_Ups product to the 
	# $Setups_Home 
	# directory, if needed.
	#======================================================================

	Name_Of_Ups=$Name_Of_Ups

	Setups_Home=$Setups_Home

	Startup_Home=$Startup_Home

	BootStrap_Dir=$BootStrap_Dir

#	Setups_Commands=$Setups_Commands

	# Setups_Products_Init_File=$Setups_Products_Init_File

	# Setups_Products_Script=$Setups_Products_Script

	# =====  DO NOT EDIT BELOW THIS LINE  ===   DO NOT REMOVE THIS LINE  ====

	$_Make_Setups_Dir_Resolve

	$_Make_Write_Test

	$_Make_Copy_If_Changed

	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================

	$_Make_Absolute_Path_Commands

	Ups_Dir=$UPS_PROD_DIR

	if test x\${Test_Prod_Dir} != x
	then
	    Ups_Dir=\$Test_Prod_Dir
	fi

	error='0'
	if test ! -f \$BootStrap_Dir/${Script_Prefix}.common
	then
	    echo '****' Configure script has failed or was not executed.
	    echo '****' \$Name_Of_Ups current script cannot execute.
	    exit 1
	fi

	if test \`echo \$Setups_Home|cut -c1\` != '/'
	then
	    Setups_Dir_Resolve Setups_Home \$Setups_Home
	fi

	Write_Test Setups_Home \$Setups_Home

	#======================================================================
	# Mark ALL BootStrap files current.
	#======================================================================
	\$rm -f /tmp/ups_cur_\$$
	for filex in \$BootStrap_Dir/set* \$BootStrap_Dir/ups*
	do
	    \$sed -e 's/Setups_Current=0/Setups_Current=1/' \$filex >/tmp/ups_cur_\$$
	    cp /tmp/ups_cur_\$$ \$filex
	    \$rm /tmp/ups_cur_\$$
	done
	#======================================================================
	# Move all the files from the bootstrap directory to 
	# $Setups_Home
	#======================================================================
	    for filex in \$BootStrap_Dir/set* \$BootStrap_Dir/ups.pm
	    do
#	        Diff_rc='0'
		file=\`echo \$filex|\$sed "s%\$BootStrap_Dir/%%"\`
		Copy_If_Changed \$filex \$Setups_Home/\${file}
		if test 0 != \$?
		then
		    error=1
		fi
	    done
	if test \$error = '1'
	then
	    echo '**** Error(s) have caused the current script to fail'
	    exit 1
	fi
	#======================================================================
	# Copy the startup and shutdown scripts to their final
	# resting place. This is sensitive to the structure
	# of the directory path.  Sub-directories may need to
	# be to be created.
	#======================================================================
	Start_Base=$Startup_Home
	for Start_Or_Stop in startup shutdown
	do
	    if test -f \$BootStrap_Dir/ups_\${Start_Or_Stop}
	    then
		if test \`echo \$Startup_Home|\$grep -c '.upsfiles'\` != 0
		then
		    Start_Base=\$Startup_Home/\$Start_Or_Stop
	 	    if test ! -d \$Start_Base
		    then
		        \$mkdir \$Start_Base
		    fi
		fi
		Copy_If_Changed \$BootStrap_Dir/ups_\${Start_Or_Stop} \
			\$Start_Base/ups_\${Start_Or_Stop}
	    	if test 0 = \$?
		then
		    \$rm -f \$Start_Base/ups_\${Start_Or_Stop}.sh
		    \$rm -f \$Start_Base/ups_\${Start_Or_Stop}.csh
	            \$ln -s \$Start_Base/ups_\${Start_Or_Stop} \$Start_Base/ups_\${Start_Or_Stop}.sh       
	            \$ln -s \$Start_Base/ups_\${Start_Or_Stop} \$Start_Base/ups_\${Start_Or_Stop}.csh
	    	    chmod +x \$Start_Base/ups_\${Start_Or_Stop}
		    chmod +x \$Start_Base/ups_\${Start_Or_Stop}.csh
		    chmod +x \$Start_Base/ups_\${Start_Or_Stop}.sh
		fi
	   fi
	done
	
	echo '**' Current script completed successfully
	    
XEoF
#======================================================================
# End of the creation of the current script
#
# Make it executable
#======================================================================
chmod +x $BootStrap_Dir/current
#======================================================================
#
# Create the uncurrent script
#======================================================================
$rm -f $BootStrap_Dir/uncurrent
echo '**' Creating $BootStrap_Dir/uncurrent
$sed 's%^	%%' <<XEoF >$BootStrap_Dir/uncurrent
	#!/bin/sh
	$URA_Disclaimer
	#
	#======================================================================
	# The ups product uncurrent script
	#
	# The goal of this script is to prevent the overlapping of cache data.
	# One of the problems with the caching of setups data is that the data
	# could wind up pointing to a non-current product instance.  The
	# instance might even have been removed.
	#
	# This script attempts to remove the cache file associated with the
	# product flavor.  The uncurrent phase of ups will make the instance
	# non-current.
	#
	# Should the removal phase fail, an error message will be printed
	# with a suggested course of action.
	#
	# This file was created when the $Name_Of_Ups product was configured.
	#======================================================================

	Name_Of_Ups=$Name_Of_Ups

	Setups_Home=$Setups_Home

#	Setups_Commands=$Setups_Commands

	# ===  DO NOT EDIT BELOW THIS LINE  =====  DO NOT REMOVE THIS LINE  =====

	$_Make_Setups_Dir_Resolve

	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================

	$_Make_Absolute_Path_Commands

	Setups_Current=0

	if test \$Setups_Current = 0
	then
	    echo '****' \$Name_Of_Ups \$UPS_PROD_VERSION \$UPS_PROD_FLAVOR
	    echo '****' is not current.
	    exit
	fi

	if test \`echo \$Setups_Home|cut -c1\` != '/'
	then
	    Setups_Dir_Resolve Setups_Home \$Setups_Home
	fi
	#======================================================================
	# Don't  try to remove a non-existant file
	#======================================================================
	if test ! -f \$Setups_Home/set\${Name_Of_Ups}.cache.\${UPS_PROD_FLAVOR}
	then
	    exit 0
	fi
	#======================================================================
	#Remove the setups.cache file from 
	# $Setups_Home
	#======================================================================
	    \$rm -f \$Setups_Home/set\${Name_Of_Ups}.cache.\${UPS_PROD_FLAVOR}
	if test -f \$Setups_Home/set\${Name_Of_Ups}.cache.\${UPS_PROD_FLAVOR}
	then
	#======================================================================
	# If we can't remove the file, print error message and fail.
	#======================================================================
	    echo '****' Cannot remove \$Setups_Home/set\${Name_Of_Ups}.cache.\${UPS_PROD_FLAVOR}
	    echo '****' Insuffient privilege.
	    echo '****'
	    echo '****' If this is being executed as part of the process of making 
	    echo '****' \$Name_Of_Ups current, the current script is also likely to fail.
	    echo '****'
	    echo '****' Please notify your System Administrator.
	    echo '****'
	    echo '****' \$Name_Of_Ups uncurrent script failed
	#    exit 1
	fi
XEoF
#======================================================================
# End of creation of uncurrent
#
# Make it executable
#======================================================================
chmod +x $BootStrap_Dir/uncurrent
#======================================================================
# Create the unconfigure script
#======================================================================
$rm -f $BootStrap_Dir/unconfigure
echo '**' Creating $BootStrap_Dir/unconfigure
$sed 's%^	%%' <<XEoF >$BootStrap_Dir/unconfigure
	#!/bin/sh
	$URA_Disclaimer
	#
	#======================================================================
	# $Name_Of_Ups unconfigure script
	#
	#
	# This script undoes the activity of the configure script.  
	#
	# It only need to know the BootStrap_Dir as defined at configure time.
	#
	# This script was created when $Name_Of_Ups was configured
	#======================================================================
	#

#	Setups_Commands=$Setups_Commands

	# ==== DO NOT EDIT BELOW THIS LINE ===== DO NOT REMOVE THIS LINE ===
	
	#======================================================================
	# Make full path variables for each command in for list
	# The for list was generated by expansion of Setups_Commands
	# defined when $Name_Of_Ups was configured.
	#======================================================================

	$_Make_Absolute_Path_Commands

	if test -d $BootStrap_Dir
	then
		echo '**' Removing the $BootStrap_Dir directory
		\$rm -rf $BootStrap_Dir
		if test -d $BootStrap_Dir
		then
		    echo '****' Unconfigure failed to remove $BootStrap_Dir
		    echo '****' Please remove this directory manually.
		    echo ' '
		fi
	fi
XEoF
#======================================================================
# End of creation of unconfigure
#
# Make it executable
#======================================================================
chmod +x $BootStrap_Dir/unconfigure
#======================================================================
# Whew 
#======================================================================
echo '**'
echo '**' $Name_Of_Ups $UPS_PROD_VERSION has been successfully configured
echo '**'
