/************************************************************************
 *
 * FILE:
 *       upsmat.c
 * 
 * DESCRIPTION: 
 *        Compare the instance(s) requested on the command line with those
 *        contined in the product UPS files and return a list of matches.
 *
 *   upsmat_instance: takes command line input and finds chain/version and
 *                      table file instance that matches it.
 *   upsmat_match_with_instance: takes a product and finds the match in a
 *                      list of instances that matches the version, flavor 
 *                      and qualifiers.
 *
 * AUTHORS:
 *       Eileen Berman
 *       David Fagan
 *       Lars Rasmussen
 *
 *       Fermilab Computing Division
 *       Batavia, Il 60510, U.S.A.
 *
 * MODIFICATIONS:
 *       25-Jul-1997, EB, first
 *
 ***********************************************************************/

/* standard include files */
#include <string.h>
#include <stdio.h>

/* ups specific include files */
#include "upsmat.h"
#include "upserr.h"
#include "upslst.h"
#include "upstyp.h"
#include "upsmem.h"
#include "upsfil.h"
#include "upsutl.h"
#include "upsget.h"
#include "upsver.h"

/*
 * Definition of public variables.
 */
extern int UPS_VERBOSE;

/*
 * Declaration of private functions.
 */
static t_upstyp_matched_product *match_instance_core(
			   const t_upsugo_command * const a_command_line,
			   const t_upstyp_db * const a_db_info,
			   const char * const a_prod_name,
			   const t_upslst_item * const a_chain_list,
			   const t_upslst_item * const a_version,
			   const int a_need_unique,
			   const int a_any_version,
			   const int a_ant_chain);
static int match_from_chain( const char * const a_product,
			     const char * const a_chain,
			     const char * const a_version,
			     const t_upsugo_command * const a_command_line,
			     const t_upstyp_db * const a_db_info,
			     const int a_need_unique,
			     const t_upslst_item * const a_flavor_list,
			     const t_upslst_item * const a_quals_list,
			     const int a_any_version,
			     t_upslst_item ** const a_minst_list);
static int match_from_version( const char * const a_product,
			       const char * const a_version,
			       const t_upsugo_command * const a_command_line,
			       const t_upstyp_db * const a_db_info,
			       const int a_need_unique,
			       const t_upslst_item * const a_flavor_list,
			       const t_upslst_item * const a_quals_list,
			       t_upslst_item ** const a_minst_list);
static int match_from_table( const char * const a_product,
			     const char * const a_tablefile,
			     const char * const a_tablefiledir,
			     const char * const a_upsdir,
			     const char * const a_productdir,
			     const t_upstyp_db * const a_db_info,
			     const int a_need_unique,
			     const t_upslst_item * const a_flavor_list,
			     const t_upslst_item * const a_quals_list,
			     t_upslst_item ** const a_minst_list);
static int get_instance(const t_upslst_item * const a_read_instances,
			const t_upslst_item * const a_flavor_list,
			const t_upslst_item * const a_quals_list,
			const int a_need_unique,
			const int a_file_type,
			t_upslst_item ** const a_minst_list);

/*
 * Definition of global variables.
 */
#ifndef NULL
#define NULL 0
#endif

/* sometimes when matching for > 1 instance, and error is found with a
   product being matched.  the match routines record that error, stop 
   matching on that product and go to the next product.  but we need to keep
   track of the error that occurred so that when we return to the calling
   routine, we can correctly report that an error occurred. and return all
   the matches that we were able to make. */
static int g_ups_error;

/* we want to keep track of when the user entered a specific 
   version on the command line.  that way when we are way down in the
   routines and the file does not exist, then we can clear the error and just
   return no matches.  if the version was obtained from the ups
   database and it does not exist, then we want to return an error. */
static int g_ugo_version = 0;


/* Prefix for any messages that are put in the error buffer. */
#define VPREFIX  "UPSMAT: "

/* This is the level of the verbose messages generated by ups match */
#define MATVLEVEL 1

/* we will use temporary lists in order to pass exactly what we want to the
   matching routines.  */
#define TMP_LISTS_SET()	\
     tmp_flavor_list.data = (void *)(inst->flavor);                  \
     tmp_quals_list.data = (void *)(inst->qualifiers);

/* we are doing an instance match only on a table file.  no database is
   involved */
#define TABLE_FILE_ONLY() \
     if (!a_command_line->ugo_version &&                                   \
	 (!a_command_line->ugo_chain || !a_command_line->ugo_c)) {         \
       /* We have a table file and no db, that is ok */                    \
       upsver_mes(MATVLEVEL, "%sNo UPS Database, using Table File - %s\n", \
		  VPREFIX, (char *)a_command_line->ugo_tablefile);         \
       mproduct = match_instance_core(a_command_line, db_info,             \
				      a_command_line->ugo_product, NULL,   \
				      NULL, a_need_unique, any_version,    \
				      any_chain);                          \
       /* update the mproduct_list structure with the new info */          \
       ADD_TO_MPRODUCT_LIST();                                             \
     } else {                                                              \
       upserr_add(UPS_TABLEFILE_AND_VERSION, UPS_FATAL);                   \
     }

/* check the list with the a_need_unique flag.  report an error if we need
   a unique instance and there is more than one on the list. */
#define CHECK_UNIQUE(a_list, type) \
      if (a_list) {                                                    \
        a_list = upslst_first(a_list);                                 \
        if (a_need_unique) {                                           \
	  /* we need a unique instance, make sure we only have one */  \
  	  if (a_list->next) {                                          \
	    /* we have more than one, this is an error */              \
            upserr_vplace();                                           \
	    upserr_add(UPS_NEED_UNIQUE, UPS_FATAL, type);              \
	    break;                                                     \
	  }                                                            \
	}                                                              \
      }

/* get a new maintched instance, fill in the correct instance pointer and add
   this matched instance to a list */
#define GET_NEW_MINST(inst_type) \
      minst = ups_new_matched_instance();                          \
      minst->inst_type = instance;                                 \
      upsmem_inc_refctr((void *)instance);                         \
      *a_minst_list = upslst_add(*a_minst_list, (void *)minst);

/* add the instance to a matched instance list.  look at the current element
   in the list and see if the type of the instance we have already is filled
   in for that matched instance.  if it is , go to the next element in the
   list or create a new element if we are at the end of the list. e.g. - we
   have matched 3 instances in a version file.  so we will have 3 matched
   instances in our matched instance list.  when we are matching in the table
   file, we are only matching one instance at a time, so we can fill in the
   table file pointer for the matched instance and then go to the next element
   on the list for our next table file. we can do this since the instances are
   always matched in the same order and only one at a time after the initial
   match. */
#define ADD_TO_MINST_LIST(inst_type) \
      if (*a_minst_list) {                                             \
	t_upslst_item *tmp_list = *a_minst_list;                       \
	t_upstyp_matched_instance *tmp_minst = NULL;                   \
	while (tmp_list) {                                             \
	  tmp_minst = (t_upstyp_matched_instance *)(tmp_list->data);   \
	  if (tmp_minst->inst_type) {                                  \
	    *a_minst_list = tmp_list;                                  \
   	    tmp_list = tmp_list->next;                                 \
	  } else {                                                     \
	    tmp_minst->inst_type = instance;                           \
	    *a_minst_list = tmp_list;                                  \
	    upsmem_inc_refctr((void *)instance);                       \
	    break;                                                     \
	  }                                                            \
	}                                                              \
	if (!tmp_list) {                                               \
	  GET_NEW_MINST(inst_type);                                    \
	}                                                              \
      } else {                                                         \
	  GET_NEW_MINST(inst_type);                                    \
      }

/* add the matched product structure to a list */
#define ADD_TO_MPRODUCT_LIST() \
      if (mproduct) {                                                  \
	mproduct->db_info = db_info;                                   \
	upsmem_inc_refctr((void *)db_info);                            \
	mproduct_list = upslst_add(mproduct_list, (void *)mproduct);   \
      }

/* read in the database configuration pointer if not done already */
#define GET_CONFIG_FILE() \
    if (db_info && !db_info->config) {               \
      config_ptr = upsutl_get_config(db_info->name); \
      if (config_ptr) {                              \
	db_info->config = config_ptr->config;        \
	upsmem_inc_refctr(db_info->config);          \
      }                                              \
    }

/* look through our list of matched instances.  remove any from
   the list if they have the invalid_instance flag set. */
#define FREE_INVALID_INSTANCES(minst_list) \
    if (minst_list) {                                                    \
      t_upslst_item *tmp_list = NULL;                                    \
      do {                                                               \
	minst = (t_upstyp_matched_instance *)minst_list->data;           \
	if (minst->invalid_instance) {                                   \
	  minst_list = upslst_delete_safe(minst_list, minst, ' ');       \
	  /* just free the structure around the instance as the rest is  \
             in the cache */                                             \
          (void) ups_free_matched_instance_structure(minst);             \
	} else {                                                         \
          tmp_list = minst_list;                                         \
          minst_list = minst_list->next;                                 \
	}                                                                \
      } while (minst_list);                                              \
      minst_list = upslst_first(tmp_list);                               \
    }



static const char linuxstr[] = "Linux";

int
linux_flavor_cmp(const char *s1, const char *s2) {
     int linuxflag=0;
     int missflag =0;
     const char *ls = linuxstr;

     upsver_mes(MATVLEVEL, "%s linux_flavor_cmp: flavor1 %s flavor2 %s\n", VPREFIX, s1, s2);

     /* basically strcmp() but ignoring text between + and - */

     if (!s1 || !s2) {
        return -1;
     }
     while( *s1 && *s2 ) {

         /* also match "Linux" string incrementally.. */
         if (!missflag && *s1 == *ls) {
             ls++;
             if (0 == *ls) {
                /* we got to the end and didn't miss any... */
                linuxflag = 1;
             }
         } else {
             missflag = 1;
         }

         if (linuxflag && *s1 == '+' && *s2 == '+' ) {
            upsver_mes(MATVLEVEL, "%s linux_flavor_cmp: skipping +something\n", VPREFIX);
            /* we hit a kernel version, skip it */
            while ( *s1 && *s1 != '-') {
                s1++;
            }
            while (*s2 && *s2 != '-') {
                s2++;
            }
         }
         if (*s1 != *s2) {
            upsver_mes(MATVLEVEL, "%s linux_flavor_cmp: returning non-zero\n", VPREFIX);
            return *s2 - *s1;
         }
         ++s1;
         ++s2;
    }
    upsver_mes(MATVLEVEL, "%s linux_flavor_cmp: returning %d\n", VPREFIX, (*s2 - *s1));
    return *s2 - *s1;
}

#define flavor_cmp linux_flavor_cmp
/* 
** #ifdef linux
** #define flavor_cmp linux_flavor_cmp
** #else
** #define flavor_cmp strcmp
** #endif
*/

/*
 * Definition of public functions.
 */

/*-----------------------------------------------------------------------
 * upsmat_instance
 *
 * Given the input from the command line, determine which products, versions
 * and chains were asked for.  Then call the matching routine to fetch them.
 * All products will be matched in the first database and then the second etc.
 *
 * Input : command line information,
 *         flag indicating if we only want one instance,
 * Output: None
 * Return: a list of matched products
 */
t_upslst_item *upsmat_instance(t_upsugo_command * const a_command_line,
			       const t_upslst_item * const a_db_info,
			       const int a_need_unique)
{
  t_upstyp_db *db_info = NULL;
  t_upslst_item *db_list;
  t_upslst_item *db_item, *all_products = NULL, *product_item;
  t_upslst_item *all_versions = NULL;
  t_upslst_item *chain_item, *all_chains = NULL, *tmp_chain = NULL;
  t_upstyp_matched_product *mproduct = NULL;
  t_upslst_item *mproduct_list = NULL;
  t_upstyp_product *config_ptr = NULL;
  char *prod_name, *the_chain, *new_string = NULL, *location = NULL;
  char do_delete = 'd';
  int got_all_products = 0, got_all_versions = 0, got_all_chains = 0;
  int need_all_chains = 0;
  int any_version = 0, any_chain = 0, allocate_new_chain = 0;
  void *saved_next = NULL;

  /* initialize this to success */
  g_ups_error = UPS_SUCCESS;
  g_ugo_version = 0;            /* assume no version file on command line */

  if (a_command_line) {
    /* In order to avoid doing this for each database, if a product name was
       entered, create a list (with 1 element) here.  if the user entered a
       specific product then we can create a list of the product to match
       here.  and then we do not have to do this for each database we will
       look at.  however if the user entered "*" for example, then he wants all
       products in each database and we need to make a new list for each
       database we encounter.  */
    if (NOT_EQUAL_ANY_MATCH(a_command_line->ugo_product)) {
      /* we only have one to list out */
      if ((new_string = upsutl_str_create(a_command_line->ugo_product,
					  STR_TRIM_DEFAULT))) {
	all_products = upslst_add(all_products, new_string);
	got_all_products = 1;
      }
    }
  
    /* In order to avoid doing this for each database, if chains were
       entered, create a list here (can only do if '*' was not one of the
       requested chains.   if the user entered a list of
       specific chains then we can create a list of the chains to match
       here.  and then we do not have to do this for each database we will
       look at.  however if the user entered "*" for example, then he wants all
       chains and we need to make a new list for each product in each
       database we encounter.  */
    if (a_command_line->ugo_chain) {
      /* first make sure none of the requested chains were '*' */
      for (chain_item = a_command_line->ugo_chain ; chain_item ;
	   chain_item = chain_item->next) {
	the_chain = (char *)(chain_item->data);
	if (! NOT_EQUAL_ANY_MATCH(the_chain)) {
	  need_all_chains = 1;
	  break;
	}
      }
      if (! need_all_chains) {
	/* none of the chains were '*' so they will remain the same for
	   all products.  just point to the list we have. */
	all_chains = a_command_line->ugo_chain;
	got_all_chains = 1;
      }
    }
    
    /* In order to avoid doing this for each database, if a version was
       entered, create a list (with 1 element) here.   if the user entered a
       specific version then we can create a list of the version to match
       here.  and then we do not have to do this for each database we will
       look at.  however if the user entered "*" for example, then he wants all
       versions and we need to make a new list for each
       product in each database we encounter.  */
    if (a_command_line->ugo_version &&
	(NOT_EQUAL_ANY_MATCH(a_command_line->ugo_version))) {
      /* we only have one to list out */
      if ((new_string = upsutl_str_create(a_command_line->ugo_version, 
					  STR_TRIM_DEFAULT))) {
	all_versions = upslst_add(all_versions, new_string);
	got_all_versions = 1;
	g_ugo_version = 1;            /* version file on command line */
      }
    }
    
    /* figure out where we are getting our database from.  if the user passed
       us a specific one in a_db_info, then we do not need to look at the
       command line to get this info. */
    if (a_db_info) {
      /* the user passed a particular one */
      db_list = (t_upslst_item *)a_db_info;
      saved_next = db_list->next;
      db_list->next = NULL;                     /* we only want this one */
    } else {
      /* this might be null but we will check for that below. */
      db_list = a_command_line->ugo_db;
    }
    
    if (db_list || a_command_line->ugo_P) {
      if (a_command_line->ugo_m && a_command_line->ugo_product &&
	  !a_command_line->ugo_version &&
	  (!a_command_line->ugo_chain || !a_command_line->ugo_c)) {
	/* We have a table file  and we have a db, use the table file as an 
	   override to what is in the db. */
	for (db_item = db_list ; db_item ; db_item = db_item->next) {
	  db_info = (t_upstyp_db *)db_item->data;
	  
	  /* first check to see that the specified database exists. */
	  if (upsutl_is_a_file(db_info->name) == UPS_SUCCESS) {
	    upsver_mes(MATVLEVEL, "%sSearching UPS database - %s\n", VPREFIX,
		       db_info->name);
	    /* If the user did not enter a product name, get all the product
	       names in the current db. */
	    if (! got_all_products) {
	      upsutl_get_files(db_info->name, (char *)ANY_MATCH,
			       &all_products);
	    }
	    
	    if (all_products) {
	      /* make sure if we need unique instance that we only have 1 */
	      CHECK_UNIQUE(all_products, "products");
	      
	      /* read in the config file associated with this database and
		 save it */
	      GET_CONFIG_FILE();
	      
	      /* for each product, get all the requested instances */
	      for (product_item = all_products ; product_item ;
		   product_item = product_item->next) {
		prod_name = (char *)product_item->data;
		
		upsver_mes(MATVLEVEL, "%sLooking for Product = %s\n",
			   VPREFIX, prod_name);
		mproduct = match_instance_core(a_command_line, db_info, 
					       prod_name, NULL, NULL,
					       a_need_unique, any_version,
					       any_chain);
		/* update the mproduct_list structure with the new info */
		ADD_TO_MPRODUCT_LIST();
	      }
	      /* may no longer need product list - free it */
	      if (! got_all_products) {
		all_products = upslst_free(all_products, do_delete);
	      }
	    }
	    /* if we have a match and are asking for a unique one, we do not
	       need to go to the next db */
	    if (a_need_unique && mproduct) {
	      break;
	    }
	  } else {
	    /* we have a table file, so see if the db is "".  if so, ignore any
	       db information and just open the table file */
	    if (db_info->name[0] == '\0') {
	      TABLE_FILE_ONLY();
	    } else {
	      upserr_add(UPS_NOT_A_DIR, UPS_WARNING, db_info->name);
	    }
	  }
	}
      } else {
	/* we have at least one db */
	for (db_item = db_list ; db_item ; db_item = db_item->next) {
	  db_info = (t_upstyp_db *)db_item->data;
	  /* first check to see that the specified database exists. */
	  if (upsutl_is_a_file(db_info->name) == UPS_SUCCESS) {
	    upsver_mes(MATVLEVEL, "%sSearching UPS database - %s\n", VPREFIX, 
		       db_info->name);
	    /* If the user did not enter a product name, get all product names
	       in the current db. */
	    if (! got_all_products) {
	      upsutl_get_files(db_info->name, (char *)ANY_MATCH,
			       &all_products);
	    }
	    if (all_products) {
	      /* make sure if we need unique instance that we only have one */
	      CHECK_UNIQUE(all_products, "products");
	    
	      /* read in the config file associated with this database and
		 save it */
	      GET_CONFIG_FILE();
	    
	      /* for each product, get all the requested instances */
	      for (product_item = all_products ; product_item ;
		   product_item = product_item->next) {
		prod_name = (char *)product_item->data;
		location = upsutl_get_prod_dir(db_info->name, prod_name);
		
		upsver_mes(MATVLEVEL, "%sLooking for Product = %s\n", VPREFIX,
			   prod_name);
	      
		/* make sure that the "product" actually exists. */
		if (upsutl_is_a_dir(location) == UPS_SUCCESS) {
		  /* Check if chains were requested. if a specific version was
		     passed, but no chain, the we will want to report all
		     chains. this is only true in the case where we are not
		     looking for a unique instance. this way we do not require
		     setup to open up all of the chain files */
		  if (a_command_line->ugo_chain ||
		      (a_command_line->ugo_version && !a_need_unique)) {
		    /* we may have already made a list of them above. check
		       before doing anything here */
		    if (! got_all_chains) {
		      if (a_command_line->ugo_version) {
			/* a specific version was entered so want to report on
			   all chains that point to the specified version */
			chain_item = upslst_new(upsutl_str_create(ANY_MATCH,
							   STR_TRIM_DEFAULT));
			allocate_new_chain = 1;
		      } else {
			chain_item = a_command_line->ugo_chain;
		      }
		      for ( tmp_chain = chain_item ; tmp_chain ;
			    tmp_chain = tmp_chain->next) {
			the_chain = (char *)(tmp_chain->data);
			if (! NOT_EQUAL_ANY_MATCH(the_chain)) {
			  /* get all the chains in the current product area */
			  upsutl_get_files(location, (char *)CHAIN_SUFFIX,
					   &all_chains);
			  any_chain = 1;          /* originally chain was *  */
			} else {
			  /* Now add this chain to the master list */
			  all_chains = upslst_add(all_chains, the_chain);
			}
		      }
		      /* clean up memory */
		      if (allocate_new_chain) {
			chain_item = upslst_free(chain_item, 'd');
		      }
		    }
		    /* make sure if we need unique instance we only have one */
		    CHECK_UNIQUE(all_chains, "chains");
		  }
		
		  /* Look to see if a version was specified. */
		  if (a_command_line->ugo_version) {
		    if (! got_all_versions) {
		      /* get all the versions in the current product area */
		      upsutl_get_files(location, (char *)VERSION_SUFFIX,
				       &all_versions);
		      any_version = 1;          /* originally version was *  */
		    }
		    /* make sure if need unique instance that only have one */
		    CHECK_UNIQUE(all_versions, "versions");
		  }
		  /* now do the instance matching */
		  mproduct = match_instance_core(a_command_line, db_info,
						 prod_name, all_chains,
						 all_versions, a_need_unique,
						 any_version, any_chain);
		  
		  /* update the mproduct_list structure with the new info */
		  ADD_TO_MPRODUCT_LIST();
		  
		  /* get out of the loop if we got an error */
		  if (UPS_ERROR != UPS_SUCCESS) {
		    if (!a_need_unique) {
		      /* we are looking for possibly many instances.  skip the
			 error if current instance could not be found and look
			 for the next one. error message is in error buffer. */
		      if (UPS_ERROR == UPS_DB_CORRUPTION) {
			  g_ups_error = UPS_ERROR;
		      } else {
			/* it was another error so pay attention to it. */
			break;
		      }
		    } else {
		      /* we are only looking for 1 instance. if we are looking
			 thru multiple databases, and have not reached the last
			 one, then ignore the error and continue on to the next
			 prod or db. */
		      if (db_item->next) {
			/* there are more databases to look thru. erase error
			   and continue. still to do - need to make sure on the
			   number of times to backup. */
			upserr_backup();
			upserr_backup();
		      } else {
			/* this was last db on the list so we need to handle
			   the error */
			break;
		      }
		    }
		  }
		  /* may no longer need version list - free it */
		  if (! got_all_versions) {
		    all_versions = upslst_free(all_versions, do_delete);
		  }
		  
		  /* may no longer need chain list - free it */
		  if (! got_all_chains) {
		    all_chains = upslst_free(all_chains, do_delete);
		  }
		} else {
		  /* the entered product does not exist in this database */
		  upsver_mes(MATVLEVEL, "%sProduct - %s does not exist\n",
			     VPREFIX, location);
		}
	      }
	      /* may no longer need product list - free it */
	      if (! got_all_products) {
		all_products = upslst_free(all_products, do_delete);
	      }
	    }
	    /* if we have a match and are asking for a unique one, we do not 
	       need to go to the next db */
	    if (a_need_unique && mproduct) {
	      break;
	    }
	  } else {
	    upserr_add(UPS_NOT_A_DIR, UPS_WARNING, db_info->name);	    
	  }
	}
      }
    } else if (a_command_line->ugo_m && a_command_line->ugo_product) {
      /* since a specific table file was entered, we need to check if a
	 version or chain was also specified.  if yes then this is an error */
      TABLE_FILE_ONLY();
    } else {
      /* we have no db and no table file or no product name, this is an 
	 error */
      upserr_vplace();
      upserr_add(UPS_NO_DATABASE, UPS_FATAL);
    }
    
    /* make sure we have cleaned up */
    if (all_products) {
      /* no longer need product list - free it */
      all_products = upslst_free(all_products, do_delete);
    }
    if (all_versions) {
      /* no longer need version list - free it */
      all_versions = upslst_free(all_versions, do_delete);
    }
    if (all_chains && (!got_all_chains)) {
      /* no longer need chain list - free it */
      all_chains = upslst_free(all_chains, do_delete);
    }      

    /* back up to the front of the list */
    mproduct_list = upslst_first(mproduct_list);
    
    /* restore the next pointer of the db list */
    if (a_db_info) {
      db_list->next = saved_next;
    }
    
    /* return any error we encountered along the way */
    if (g_ups_error != UPS_SUCCESS) {
      UPS_ERROR = g_ups_error;
    }
  } /* if (a_command_line) */
  return(mproduct_list);
}

/*-----------------------------------------------------------------------
 * upsmat_version
 *
 * Given a version instance, find the appropriate match in the associated
 * table file.  This routine is really just an interface to match_from_table.
 *
 * Input : version instance,
 *         flag indicating if we only want one instance,
 * Output: None
 * Return: a list of matched products
 */
t_upstyp_instance *upsmat_version(t_upstyp_instance * const a_inst,
				  const t_upstyp_db * const a_db_info)
{
  t_upslst_item *minst_list = NULL;
  t_upslst_item flavor_list = {NULL, NULL, NULL};
  t_upslst_item *flavor_list_ptr = &flavor_list;
  t_upslst_item any_flavor_list = {NULL, ANY_FLAVOR, NULL};
  t_upslst_item quals_list = {NULL, NULL, NULL};
  t_upstyp_matched_instance *minst = NULL;
  t_upstyp_instance *tinst = NULL;
  int num_matches;
  int need_unique = 1;

  
  flavor_list_ptr = upslst_add_list(flavor_list_ptr, &any_flavor_list);
  if (a_inst) {
    /* fill in the flavor list and the qualifer list */
    if (a_inst->flavor) {
      flavor_list.data = (void *)a_inst->flavor;
    }
    if (a_inst->qualifiers) {
      quals_list.data = (void *)a_inst->qualifiers;
    }

    /* go get the table file */
    num_matches = match_from_table(a_inst->product, a_inst->table_file,
				   a_inst->table_dir, a_inst->ups_dir,
				   a_inst->prod_dir, a_db_info, need_unique,
				   &flavor_list, &quals_list, &minst_list);
    if (num_matches > 0) {
      minst = (t_upstyp_matched_instance *)minst_list->data;
      tinst = minst->table;
      upsmem_free(minst);
      (void) upslst_free(minst_list, ' ');
    }
  }
  return(tinst);
}

/*-----------------------------------------------------------------------
 * upsmat_match_with_instance
 *
 * Given an instance and a read in product structure, return a pointer
 * to the instance (in the product structure) that matches (version, flavor
 * and quals) the passed in instance.  This will be used for example. to pick
 * out chains that point to already matched versions. (NOTE: this will not
 * currently work when one of the instances is read in from a table file as 
 * the instance may have flavor or qualifiers set to "*".  this matches all 
 * but the compare will not pick that up.)
 * 
 *
 * Input : instance, and a read in product structure
 * Output: None
 * Return: the instance list item pointer that matches.
 *         if no match, then NULL.
 */
t_upslst_item *upsmat_match_with_instance(
				    const t_upstyp_instance * const a_instance,
				    const t_upstyp_product * const a_product)
{
  t_upslst_item *instance_list = NULL;
  t_upstyp_instance *inst = NULL;

  if (a_instance && a_product && a_instance->version) {
    for (instance_list = a_product->instance_list ; instance_list ;
	 instance_list = instance_list->next) {
      inst = (t_upstyp_instance *)instance_list->data;
      if (inst->version) {       /* make sure we have one */
	if (! strcmp(a_instance->version, inst->version)) {
	  /* they are the same version */
	  if (! flavor_cmp(a_instance->flavor, inst->flavor)) {
	    /* they have the same flavor */
	    if (! strcmp(a_instance->qualifiers, inst->qualifiers)) {
	      /* they have same qualifiers, we found a match, return it */
	      inst->flag = 1;
	      break;
	    }
	  }
	}
      }
    }
  }
  return(instance_list);
}

/*
 * Definition of private globals.
 */

/*
 * Definition of private functions.
 */

/*-----------------------------------------------------------------------
 * match_instance_core
 *
 * Actually do all the matching work for the product and version.
 *
 * Input : the command line input, a database, product name, list of chains,
 *         list of versions and a flag specifying a unique instance is desired.
 * Output: none
 * Return: a pointer to the instances matched from the files read.
 */
static t_upstyp_matched_product *match_instance_core(
				 const t_upsugo_command * const a_command_line,
				 const t_upstyp_db * const a_db_info,
				 const char * const a_prod_name,
				 const t_upslst_item * const a_chain_list,
				 const t_upslst_item * const a_version_list,
				 const int a_need_unique,
				 const int a_any_version,
				 const int a_any_chain)
{
  t_upstyp_matched_product *mproduct = NULL;
  t_upslst_item *tmp_minst_list = NULL, *vminst_list = NULL;
  t_upslst_item *master_minst_list = NULL, *matched_item = NULL;
  t_upslst_item *chain_list = NULL, *version_list = NULL;
  t_upstyp_matched_instance *minst = NULL;
  t_upstyp_product *read_product = NULL;
  t_upslst_item *item = NULL;
  t_upstyp_instance *inst = NULL;
  int num_matches = 0, tmp_num_matches;
  char *chain, *version, *dummy;

  /* see if we were passed a table file. if so, don't worry about
     version and chain files, just read the table file */
  if (a_command_line->ugo_m  && (! a_command_line->ugo_version)	&&
      (!a_command_line->ugo_chain || !a_command_line->ugo_c)) {
    upsver_mes(MATVLEVEL, "%sMatching with Table file  - %s\n", VPREFIX,
	     a_command_line->ugo_tablefile);
    num_matches = match_from_table(a_prod_name,
				   a_command_line->ugo_tablefile,
				   a_command_line->ugo_tablefiledir,
				   a_command_line->ugo_upsdir,
				   a_command_line->ugo_productdir, a_db_info, 
				   a_need_unique, a_command_line->ugo_flavor,
				   a_command_line->ugo_qualifiers,
				   &master_minst_list);
    /* clean out any invalid instances */
    FREE_INVALID_INSTANCES(master_minst_list);

    if ((num_matches > 0) && master_minst_list) {
      /* we got some matches, fill out our matched product structure */
      mproduct = ups_new_matched_product(a_db_info, a_prod_name,
					 master_minst_list);
    }
    
  /* we were not passed a specific list of chains (or we were passed no chains
     at all) and we have some versions,  start by reading the version files. */
  } else if ((a_any_chain || !a_chain_list) && a_version_list) { 
    for (version_list = (t_upslst_item *)a_version_list; version_list;
	 version_list = version_list->next) {
      /* get the version */
      version = (char *)version_list->data;
      upsver_mes(MATVLEVEL, "%sMatching with Version - %s\n", VPREFIX,
		 version);
      tmp_num_matches = match_from_version(a_prod_name, version,
					   a_command_line,
					   a_db_info, a_need_unique,
					   a_command_line->ugo_flavor,
					   a_command_line->ugo_qualifiers, 
					   &tmp_minst_list);

      /* clean out any invalid instances */
      FREE_INVALID_INSTANCES(tmp_minst_list);

      /* append matched instances to master list */
      master_minst_list = upslst_add_list(master_minst_list, tmp_minst_list);
      tmp_minst_list = NULL;

      num_matches += tmp_num_matches;
    }
    if (a_chain_list && (num_matches > 0)) {
      /* Now we need to go thru the list of chains that were passed us, read in
	 each file, and associate any chains with the matched version
	 instances */
      for (chain_list = (t_upslst_item *)a_chain_list ; chain_list ;
	   chain_list = chain_list->next) {
	/* get the chain name */
	chain = (char *)chain_list->data;
	read_product = upsget_chain_file(a_db_info->name, a_prod_name, chain, &dummy);
	if ((UPS_ERROR == UPS_SUCCESS) && read_product) {
	  for (vminst_list = master_minst_list ; vminst_list ; 
	       vminst_list = vminst_list->next) {
	    minst = (t_upstyp_matched_instance *)vminst_list->data;
	    if (minst->version) {       /* make sure we have one */
	      if ((matched_item = 
		   upsmat_match_with_instance(minst->version, read_product))) {
		/* this is a match */
		upsver_mes(MATVLEVEL, "%sFound associated chain - %s\n",
			   VPREFIX, chain);
		if (! minst->chain ) {
		  /* no chain here yet, fill it in */
		  minst->chain = (t_upstyp_instance *)matched_item->data;
		  upsmem_inc_refctr((void *)minst->chain);
		} else {
		  /* we need to add a list element to the list of extra
		     chains */
		  minst->xtra_chains = upslst_add(minst->xtra_chains,
				      (t_upstyp_instance *)matched_item->data);
		}
	      }
	    }
	  }
	  if (UPS_VERIFY) {
	    /* see if we have a chain without a matching version.
	       if we asked for all of everything, then this is wrong. */
	    if (a_command_line->ugo_a &&
		!(a_command_line->ugo_c || a_command_line->ugo_o ||
		  a_command_line->ugo_n || a_command_line->ugo_d ||
		  a_command_line->ugo_t || a_command_line->ugo_g ||
		  a_command_line->ugo_f || a_command_line->ugo_H ||
		  a_command_line->ugo_q || a_command_line->ugo_number) &&
		(! NOT_EQUAL_ANY_MATCH(a_command_line->ugo_version))) {
	      for (item = read_product->instance_list ; item ;
		   item = item->next) {
		inst = (t_upstyp_instance *)item->data;
		if (! inst->flag) {
		  /* no match was made for this instance */
		  upserr_add(UPS_DANGLING_CHAIN, UPS_WARNING, chain);
		  upserr_add(UPS_PRODUCT_INFO,UPS_WARNING, a_prod_name, 
			     (inst->version    ? inst->version    : " "),
			     (inst->flavor     ? inst->flavor     : " "),
			     (inst->qualifiers ? inst->qualifiers : " "));
		}
	      }
	    }
	  }
	} else if (UPS_ERROR == UPS_NO_FILE) {
	  /* if we could not find the file, then clear out the error.
	     otherwise if a ups list is done on an entire db for test chain,
	     all products without a test chain will generate an error. */
	  upserr_backup();
	  upserr_backup();
	}
      }

      /* return the xtra chain lists to the first list element */
      for (vminst_list = master_minst_list ; vminst_list ; 
	   vminst_list = vminst_list->next) {
	minst = (t_upstyp_matched_instance *)vminst_list->data;
	if (minst->xtra_chains) {
	  minst->xtra_chains = upslst_first(minst->xtra_chains);
	}
      }
    }

    /* We went thru the list of versions, get a matched product
       structure if we got no errors */
    if ((num_matches > 0) && master_minst_list) {
      mproduct = ups_new_matched_product(a_db_info, a_prod_name,
					 master_minst_list);
    }
  } else if (a_chain_list) {
    /* we need to start with any requested chains and find the associated
       version and then table files. */
    for (chain_list = (t_upslst_item *)a_chain_list; chain_list;
	 chain_list = chain_list->next) {
      /* get the chain name */
      chain = (char *)chain_list->data;
      upsver_mes(MATVLEVEL, "%sMatching with Chain - %s\n", VPREFIX, chain);
      tmp_num_matches = match_from_chain(a_prod_name, chain, 
					 a_command_line->ugo_version,
					 a_command_line, a_db_info, 
					 a_need_unique,
					 a_command_line->ugo_flavor,
					 a_command_line->ugo_qualifiers, 
					 a_any_version, &tmp_minst_list);
      /* clean out any invalid instances */
      FREE_INVALID_INSTANCES(tmp_minst_list);

      /* append matched instances to master list */
      master_minst_list = upslst_add_list(master_minst_list, tmp_minst_list);
      tmp_minst_list = NULL;

      num_matches += tmp_num_matches;
    }

    /* We went thru the list of chain instances, get a matched product
       structure if we got any matches */
    if ((num_matches > 0) && master_minst_list) {
      mproduct = ups_new_matched_product(a_db_info, a_prod_name,
					 master_minst_list);
    }
  }

  return mproduct;
}

/*-----------------------------------------------------------------------
 * match_from_chain
 *
 * Given the the command line inputs, return the matched instances read in
 * from the chain file, version file, and the table file.
 *
 * Input : product name, chain name, version from command line,
 *         table file name, table file directory
 *         product ups directory, product root directory,
 *         db name, unique instance flag,
 *         pointer to a list of flavors to match,
 *         pointer to a list of qualifiers to match,
 *         pointer to a list of instances (chain, version and table)
 * Output: pointer to updated lists of matched instances
 * Return: number of instances added to the list
 */
static int match_from_chain( const char * const a_product,
			     const char * const a_chain,
			     const char * const a_version,
			     const t_upsugo_command * const a_command_line,
			     const t_upstyp_db * const a_db_info,
			     const int a_need_unique,
			     const t_upslst_item * const a_flavor_list,
			     const t_upslst_item * const a_quals_list,
			     const int a_any_version,
			     t_upslst_item ** const a_minst_list)
{
  int num_matches = 0, tmp_num_matches = 0;
  t_upstyp_product *read_product;
  t_upslst_item *cinst, *minst_item;
  t_upstyp_instance *inst = NULL;
  t_upstyp_matched_instance *tmp_minst_ptr = NULL, *minst;
  char *buffer = NULL;
  int do_need_unique = 1;
  t_upslst_item tmp_flavor_list = {NULL, NULL, NULL};
  t_upslst_item tmp_quals_list = {NULL, NULL, NULL};

  read_product = upsget_chain_file(a_db_info->name, a_product, a_chain,
				   &buffer);
  if ((UPS_ERROR == UPS_SUCCESS) && read_product) {
    /* get all the instances that match command line input */
    tmp_num_matches = get_instance(read_product->instance_list,
				   a_flavor_list, a_quals_list,
				   a_need_unique, e_file_chain,
				   a_minst_list);
    upsver_mes(MATVLEVEL, "%sFound %d instances in %s\n", VPREFIX,
	       tmp_num_matches, buffer);
    if (UPS_VERIFY && tmp_num_matches) {
      /* verify that if there was a chain keyword in the file, that it
	 matches the filename */
      for (minst_item = *a_minst_list ; minst_item ; 
	   minst_item = minst_item->next) {
	minst = (t_upstyp_matched_instance *)minst_item->data;
	if (minst->chain && minst->chain->chain &&
	    strcmp(minst->chain->chain, a_chain)) {
	  upserr_add(UPS_MISMATCH_CHAIN, UPS_WARNING, minst->chain->chain,
		     a_chain);
	}
      }
    }
    
    /* for each instance that was matched, open the version file, and only
       look for the instance that matches the instance found in the chain
       file.  this insures that an instance in a chain file is
       matched only with an instance in the associated version file. */
    if ((cinst = *a_minst_list)) {
      do {
	/* get a matched instance */
	tmp_minst_ptr = (t_upstyp_matched_instance *)(cinst->data);
	inst = tmp_minst_ptr->chain;
	
	/* check to see if a specific version was entered along with the
	   chain.  if so, then we only match those chains that point to the
	   same version as that which was entered. */
	if (a_version && !a_any_version) {
	  /* compare the entered version with the one associated with the
	     chain. if they do not match, get the next chain */
	  if (strcmp(inst->version, a_version)) {
	    /* mark this item to be deleted */
	    tmp_minst_ptr->invalid_instance = 1;
	    continue;
	  }
	} /* if (a_version && !a_any_version) */

	/* make 2 lists (tmp_flavor_list and tmp_quals_list), one of the 
	   desired flavor and one of the desired qualifier to match */
	TMP_LISTS_SET();

	upsver_mes(MATVLEVEL, "%sMatching with Version %s in Product %s\n",
		   VPREFIX, inst->version, a_product);
	upsver_mes(MATVLEVEL, "%sUsing Flavor = %s, and Qualifiers = %s\n",
		   VPREFIX, (char *)(tmp_flavor_list.data),
		   (char *)(tmp_quals_list.data));
	tmp_num_matches = match_from_version(a_product, inst->version,
					     a_command_line, a_db_info,
					     do_need_unique, &tmp_flavor_list,
					     &tmp_quals_list, &cinst);
	if (tmp_num_matches == 0 && (UPS_ERROR != UPS_NO_TABLE_MATCH )) {
	  /* We should have had a match, this is an error */
	  upserr_vplace();
	  upserr_add(UPS_NO_VERSION_MATCH, UPS_FATAL, buffer,
		     inst->version);
	  upserr_add(UPS_DB_CORRUPTION, UPS_FATAL, a_db_info->name, a_product);
	  /* mark this item to be deleted */
	  tmp_minst_ptr->invalid_instance = 1;
	} else {
	  /* keep a running total of the matches we found */
	  num_matches = num_matches + tmp_num_matches;
	}
	/* only point cinst to the next element on the list if there is one 
	   and if there was no error in which case we are already pointing
	   there */
      } while (cinst->next && (cinst = cinst->next));
    
    *a_minst_list = upslst_first(cinst);
    } /* if (cinst) */
  } else if (UPS_ERROR == UPS_NO_FILE) {
    /* if we could not find the file then clear out the error.  otherwise if
       a ups list is done on an entire db for test chain, all products without
       a test chain will generate an error */
    upserr_backup();
    upserr_backup();
  }
  
return num_matches;
}

/*-----------------------------------------------------------------------
 * match_from_version
 *
 * Given the command line inputs, return the matched instances read in
 * from the version file and the table file.
 *
 * Input : product name, product version, 
 *         table file name, table file directory
 *         product ups directory, product root directory,
 *         db name, unique instance flag,
 *         pointer to a list of flavors to match,
 *         pointer to a list of qualifiers to match,
 *         pointer to a list of instances (version and table)
 * Output: pointer to updated lists of matched instances
 * Return: number of instances added to the list
 */
static int match_from_version( const char * const a_product,
			       const char * const a_version,
			       const t_upsugo_command * const a_command_line,
			       const t_upstyp_db * const a_db_info,
			       const int a_need_unique,
			       const t_upslst_item * const a_flavor_list,
			       const t_upslst_item * const a_quals_list,
			       t_upslst_item ** const a_minst_list)
{

  int file_chars, num_matches = 0, tmp_num_matches = 0;
  char buffer[FILENAME_MAX+1], *tmp_version = "";
  t_upstyp_product *read_product;
  t_upslst_item *vinst, *minst_item;
  t_upslst_item tmp_any_flavor_list = {NULL, ANY_FLAVOR, NULL};
  t_upslst_item tmp_flavor_list = {NULL, NULL, NULL};
  t_upslst_item tmp_quals_list = {NULL, NULL, NULL};
  t_upstyp_instance *inst;
  t_upstyp_matched_instance *tmp_minst_ptr = NULL, *minst;
  char *tmp_upsdir, *tmp_productdir, *tmp_tabledir, *tmp_tablefile;
  int do_need_unique = 1;

  tmp_any_flavor_list.prev = &tmp_flavor_list;
  tmp_flavor_list.next = &tmp_any_flavor_list;
  if (a_version) {
    tmp_version = (char *)a_version;
  }

  /* Get total length of version file name including path */
  file_chars = (int )(strlen(tmp_version) + strlen(a_product) +
		      strlen(a_db_info->name) + sizeof(VERSION_SUFFIX) + 4);
  if (file_chars <= FILENAME_MAX) {
    (void) sprintf(buffer, "%s/%s/%s%s", a_db_info->name, a_product, tmp_version,
	    VERSION_SUFFIX);
    read_product = upsfil_read_file(&buffer[0]);
    if ((UPS_ERROR == UPS_SUCCESS) && read_product) {
      /* get all the instances that match command line input */
      tmp_num_matches = get_instance(read_product->instance_list,
				     a_flavor_list, a_quals_list,
				     a_need_unique, e_file_version, 
				     a_minst_list);
      upsver_mes(MATVLEVEL, "%sFound %d instances in %s\n", VPREFIX,
                 tmp_num_matches, buffer);
      if (UPS_VERIFY && tmp_num_matches) {
	/* verify that if there was a version keyword in the file, that it
	   matches the filename */
	for (minst_item = *a_minst_list ; minst_item ; 
	     minst_item = minst_item->next) {
	  minst = (t_upstyp_matched_instance *)minst_item->data;
	  if (minst->version && minst->version->version &&
	      strcmp(minst->version->version, tmp_version)) {
	    upserr_add(UPS_MISMATCH_VERSION, UPS_WARNING, 
		       minst->version->version, tmp_version);
	  }
	}
      }

      /* for each instance that was matched, open the table file, and only
	 look for the instance that matches the instance found in the version
	 file.  this insures that an instance in a version file is
	 matched only with an instance in the associated table file. */
      if ((vinst = *a_minst_list)) {
	do {
	  /* get an instance and thus a table file */
	  tmp_minst_ptr = (t_upstyp_matched_instance *)(vinst->data);
	  if ((inst = tmp_minst_ptr->version) != NULL) {
	    /* It is ok if we do not have a table file.  then we just do
	       whatever the default action is */
	    if (inst->table_file || a_command_line->ugo_m) {
	      /* make 2 lists (tmp_flavor_list and tmp_quals_list), one of the 
		 desired flavor and one of the desired qualifier to match */
	      TMP_LISTS_SET();
	      
	      /* see if any command line info should override what we read from
		 the files */
	      if (a_command_line->ugo_U) {
		tmp_upsdir = (char *)a_command_line->ugo_upsdir;
	      } else {
		tmp_upsdir = inst->ups_dir;
	      }
	      if (a_command_line->ugo_M) {
		tmp_tabledir = (char *)a_command_line->ugo_tablefiledir;
	      } else {
		tmp_tabledir = inst->table_dir;
	      }
	      if (a_command_line->ugo_r) {
		tmp_productdir = (char *)a_command_line->ugo_productdir;
	      } else {
		tmp_productdir = inst->prod_dir;
	      }
	      if (a_command_line->ugo_m) {
		tmp_tablefile = (char *)a_command_line->ugo_tablefile;
	      } else {
		tmp_tablefile = inst->table_file;
	      }

	      upsver_mes(MATVLEVEL, 
			 "%sMatching with Version %s in Product %s using Table file %s\n",
			 VPREFIX, inst->version, a_product, tmp_tablefile);
	      upsver_mes(MATVLEVEL, "%sUsing Flavor %s and Qualifiers %s\n",
			 VPREFIX, (char *)(tmp_flavor_list.data),
			 (char *)(tmp_quals_list.data));
	      tmp_num_matches = match_from_table(a_product, tmp_tablefile,
						 tmp_tabledir, tmp_upsdir,
						 tmp_productdir, a_db_info,
						 do_need_unique,
						 &tmp_flavor_list, 
						 &tmp_quals_list, &vinst);
	      if (tmp_num_matches == 0) {
		/* We should have had a match, this is an error */
		upserr_vplace();
		upserr_add(UPS_NO_TABLE_MATCH, UPS_FATAL, buffer,
			   tmp_tablefile, inst->flavor, inst->qualifiers);
		upserr_add(UPS_DB_CORRUPTION, UPS_FATAL, a_db_info->name,
			   a_product);

		/* mark this item to be deleted */
		tmp_minst_ptr->invalid_instance = 1;
	      } else {
		/* keep a running total of the matches we found */
		++num_matches;
	      }
	    } else {
	      /* this one did not have a table file so we just record the
		 match from the version file */
	      ++num_matches;
	    }
	  } else {
	    /* There are no more version matched instances filled out here */
	    break;
	  }
	} while (vinst->next && (vinst = vinst->next));
      }
    } else if ((UPS_ERROR == UPS_NO_FILE) && (g_ugo_version)) {
      /* if we could not find the file and a version was entered on the 
	 command line then clear out the error.  otherwise if a ups list is
	 done on an entire db for v2_0, all products without a v2_0 will
	 generate an error */
      upserr_backup();
      upserr_backup();
    }
  } else {
    upserr_vplace();
    upserr_add(UPS_FILENAME_TOO_LONG, UPS_FATAL, file_chars);
  }

  return num_matches;
}

/*-----------------------------------------------------------------------
 * match_from_table
 *
 * Given the the command line inputs, return the matched instances read in
 * from the table file.
 *
 * Input : product name, a table file, a table file directory,
 *         products' ups directory, product root directory,
 *         db name, unique instance flag,
 *         pointer to a list of flavors to match,
 *         pointer to a list of qualifiers to match,
 *         pointer to a list of instances (table)
 * Output: pointer to an updated list of matched instances
 * Return: number of instances added to the list
 */
static int match_from_table( const char * const a_product,
			     const char * const a_tablefile,
			     const char * const a_tablefiledir,
			     const char * const a_upsdir,
			     const char * const a_productdir,
			     const t_upstyp_db * const a_db_info,
			     const int a_need_unique,
			     const t_upslst_item * const a_flavor_list,
			     const t_upslst_item * const a_quals_list,
			     t_upslst_item ** const a_minst_list)
{
  char *full_table_file;
  t_upstyp_product *read_product;
  int num_matches = 0;

  full_table_file = upsget_table_file(a_product, a_tablefile,
				      a_tablefiledir, a_upsdir,
				      a_productdir, a_db_info,
				      MUST_EXIST);

  if (full_table_file != NULL) {
    if ((read_product = upsfil_read_file(full_table_file)) != NULL) {
      /* get all the instances that match command line input */
      num_matches = get_instance(read_product->instance_list, a_flavor_list,
				 a_quals_list, a_need_unique, e_file_table,
				 a_minst_list);
      upsver_mes(MATVLEVEL, "%sFound %d instances in %s\n", VPREFIX,
		 num_matches, full_table_file);
    }
  }
  
  return num_matches;
}

/*-----------------------------------------------------------------------
 * get_instance
 *
 * Given a list of instances locate the best match with the flavor and
 * qualifier arrays.
 *
 * Input : a list of instances read in from a file,
 *         list of flavors to match,
 *         list of qualifiers to match,
 *         flag indicating if a unique instance is desired
 *         a list (empty or not) of instances
 * Output: pointer to last element on updated list of instances
 * Return: number of instances added to the list
 */
static int get_instance(const t_upslst_item * const a_read_instances,
			const t_upslst_item * const a_flavor_list,
			const t_upslst_item * const a_quals_list,
			const int a_need_unique,
			const int a_file_type,
			t_upslst_item ** const a_minst_list)
{
  int got_match;
  t_upslst_item *tmp_list, *tmp_flavor_list, *tmp_quals_list;
  t_upstyp_matched_instance *minst = NULL;
  t_upstyp_instance *instance;
  t_upslst_item *first_matched_inst = NULL;
  char *flavor = NULL, *quals = NULL;
  int num_matches  = 0, want_all_f = 1, want_all_q = 1;

  /* loop over all the flavors from the flavor list */
  for (tmp_flavor_list = (t_upslst_item *)a_flavor_list; tmp_flavor_list ;
       tmp_flavor_list = tmp_flavor_list->next) {
    flavor = (char *)tmp_flavor_list->data;
    got_match = 0;
    want_all_f = (! NOT_EQUAL_ANY_MATCH(flavor));   /* true if flavor = *  */

    for (tmp_quals_list = (t_upslst_item *)a_quals_list; tmp_quals_list ;
	 tmp_quals_list = tmp_quals_list->next) {
      quals = (char *)tmp_quals_list->data;

      upsver_mes(MATVLEVEL, "%s get_instance: flavor %s quals %s\n", VPREFIX,
			flavor, quals);

      want_all_q = (! NOT_EQUAL_ANY_MATCH(quals));   /* true if quals = *  */
      /* Check to see if the flavors match or want any flavor */
      for (tmp_list = (t_upslst_item *)a_read_instances; tmp_list ;
	   tmp_list = tmp_list->next) {
	instance = (t_upstyp_instance *)(tmp_list->data);
        upsver_mes(MATVLEVEL, "inst flavor %s\n", instance->flavor);
	if (want_all_f || (! flavor_cmp(instance->flavor, flavor))) {
	  /* They do - now compare the qualifiers */
          upsver_mes(MATVLEVEL, "Found flavor...\n");
	  if (want_all_q || (! strcmp(instance->qualifiers, quals))) {
	    /* They do. Save the instances in the order they came in. */
            upsver_mes(MATVLEVEL, "Found one!\n");
	    if (a_file_type == e_file_chain) {
	      /* this instance was read in from a chain file, create a new
	         matched instance structure and start to fill it */
	      ADD_TO_MINST_LIST(chain);
	    } else if (a_file_type == e_file_version) {
	      /* this instance was read in from a version file */
	      ADD_TO_MINST_LIST(version);
	    } else {
	      /* this instance was read in from a table file */
	      ADD_TO_MINST_LIST(table);
	    }

	    if (first_matched_inst == NULL) {
	      /* Save this so we can return it - this is the first new instance
	         we added to the list this time */
              upsver_mes(MATVLEVEL, "First post!\n");
	      first_matched_inst = *a_minst_list;
	    }
	    ++num_matches;
	    got_match = 1;
	    if ((!want_all_q && !want_all_f) || a_need_unique) {
	      break;
	    }
  	  }
	}
      }
      /* if we got a match and we only want one, break. */
      if (got_match && a_need_unique) {
	/* go get the next flavor */
	break;
      }
    }
    /* If we only want one instance - we got it, leave now */
    if (a_need_unique && got_match) {
      break;
    }
  }

  /* if we matched 1 or more instances this time, return a pointer to the first
     instance that was matched.  if no match was made, return what we were
     passed */
  if (first_matched_inst != NULL) {
    *a_minst_list = first_matched_inst;
  }

  return num_matches;
}
